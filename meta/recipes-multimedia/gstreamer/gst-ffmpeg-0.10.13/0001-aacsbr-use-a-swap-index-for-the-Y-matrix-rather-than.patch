From cc412b71047ebf77c7e810c90b044f018a1c0c2d Mon Sep 17 00:00:00 2001
From: Christophe Gisquet <christophe.gisquet@gmail.com>
Date: Thu, 23 Feb 2012 22:25:44 +0000
Subject: [PATCH] aacsbr: use a swap index for the Y matrix rather than copy
 buffers.

Signed-off-by: Alex Converse <alex.converse@gmail.com>
---
 libavcodec/aacsbr.c |   33 +++++++++++++++++++--------------
 libavcodec/sbr.h    |    1 +
 2 files changed, 20 insertions(+), 14 deletions(-)

diff --git a/gst-libs/ext/libav/libavcodec/aacsbr.c b/gst-libs/ext/libav/libavcodec/aacsbr.c
index 3a30fca..f5ac30f 100644
--- a/gst-libs/ext/libav/libavcodec/aacsbr.c
+++ b/gst-libs/ext/libav/libavcodec/aacsbr.c
@@ -1407,8 +1407,8 @@ static int sbr_hf_gen(AACContext *ac, SpectralBandReplication *sbr,
 
 /// Generate the subband filtered lowband
 static int sbr_x_gen(SpectralBandReplication *sbr, float X[2][38][64],
-                     const float X_low[32][40][2], const float Y[2][38][64][2],
-                     int ch)
+                     const float Y0[38][64][2], const float Y1[38][64][2],
+                     const float X_low[32][40][2], int ch)
 {
     int k, i;
     const int i_f = 32;
@@ -1422,8 +1422,8 @@ static int sbr_x_gen(SpectralBandReplication *sbr, float X[2][38][64],
     }
     for (; k < sbr->kx[0] + sbr->m[0]; k++) {
         for (i = 0; i < i_Temp; i++) {
-            X[0][i][k] = Y[0][i + i_f][k][0];
-            X[1][i][k] = Y[0][i + i_f][k][1];
+            X[0][i][k] = Y0[i + i_f][k][0];
+            X[1][i][k] = Y0[i + i_f][k][1];
         }
     }
 
@@ -1435,8 +1435,8 @@ static int sbr_x_gen(SpectralBandReplication *sbr, float X[2][38][64],
     }
     for (; k < sbr->kx[1] + sbr->m[1]; k++) {
         for (i = i_Temp; i < i_f; i++) {
-            X[0][i][k] = Y[1][i][k][0];
-            X[1][i][k] = Y[1][i][k][1];
+            X[0][i][k] = Y1[i][k][0];
+            X[1][i][k] = Y1[i][k][1];
         }
     }
     return 0;
@@ -1602,7 +1602,8 @@ static void sbr_gain_calc(AACContext *ac, SpectralBandReplication *sbr,
 }
 
 /// Assembling HF Signals (14496-3 sp04 p220)
-static void sbr_hf_assemble(float Y[2][38][64][2], const float X_high[64][40][2],
+static void sbr_hf_assemble(float Y1[38][64][2],
+                            const float X_high[64][40][2],
                             SpectralBandReplication *sbr, SBRData *ch_data,
                             const int e_a[2])
 {
@@ -1624,7 +1625,6 @@ static void sbr_hf_assemble(float Y[2][38][64][2], const float X_high[64][40][2]
     float (*g_temp)[48] = ch_data->g_temp, (*q_temp)[48] = ch_data->q_temp;
     int indexnoise = ch_data->f_indexnoise;
     int indexsine  = ch_data->f_indexsine;
-    memcpy(Y[0], Y[1], sizeof(Y[0]));
 
     if (sbr->reset) {
         for (i = 0; i < h_SL; i++) {
@@ -1653,17 +1653,17 @@ static void sbr_hf_assemble(float Y[2][38][64][2], const float X_high[64][40][2]
                     float g_filt = 0.0f;
                     for (j = 0; j <= h_SL; j++)
                         g_filt += g_temp[idx1 - j][m] * h_smooth[j];
-                    Y[1][i][m + kx][0] =
+                    Y1[i][m + kx][0] =
                         X_high[m + kx][i + ENVELOPE_ADJUSTMENT_OFFSET][0] * g_filt;
-                    Y[1][i][m + kx][1] =
+                    Y1[i][m + kx][1] =
                         X_high[m + kx][i + ENVELOPE_ADJUSTMENT_OFFSET][1] * g_filt;
                 }
             } else {
                 for (m = 0; m < m_max; m++) {
                     const float g_filt = g_temp[i + h_SL][m];
-                    Y[1][i][m + kx][0] =
+                    Y1[i][m + kx][0] =
                         X_high[m + kx][i + ENVELOPE_ADJUSTMENT_OFFSET][0] * g_filt;
-                    Y[1][i][m + kx][1] =
+                    Y1[i][m + kx][1] =
                         X_high[m + kx][i + ENVELOPE_ADJUSTMENT_OFFSET][1] * g_filt;
                 }
             }
@@ -1672,9 +1672,9 @@ static void sbr_hf_assemble(float Y[2][38][64][2], const float X_high[64][40][2]
                 for (m = 0; m < m_max; m++) {
                     indexnoise = (indexnoise + 1) & 0x1ff;
                     if (sbr->s_m[e][m]) {
-                        Y[1][i][m + kx][0] +=
+                        Y1[i][m + kx][0] +=
                             sbr->s_m[e][m] * phi[0][indexsine];
-                        Y[1][i][m + kx][1] +=
+                        Y1[i][m + kx][1] +=
                             sbr->s_m[e][m] * (phi[1][indexsine] * phi_sign);
                     } else {
                         float q_filt;
@@ -1686,9 +1686,9 @@ static void sbr_hf_assemble(float Y[2][38][64][2], const float X_high[64][40][2]
                         } else {
                             q_filt = q_temp[i][m];
                         }
-                        Y[1][i][m + kx][0] +=
+                        Y1[i][m + kx][0] +=
                             q_filt * sbr_noise_table[indexnoise][0];
-                        Y[1][i][m + kx][1] +=
+                        Y1[i][m + kx][1] +=
                             q_filt * sbr_noise_table[indexnoise][1];
                     }
                     phi_sign = -phi_sign;
@@ -1696,9 +1696,9 @@ static void sbr_hf_assemble(float Y[2][38][64][2], const float X_high[64][40][2]
             } else {
                 indexnoise = (indexnoise + m_max) & 0x1ff;
                 for (m = 0; m < m_max; m++) {
-                    Y[1][i][m + kx][0] +=
+                    Y1[i][m + kx][0] +=
                         sbr->s_m[e][m] * phi[0][indexsine];
-                    Y[1][i][m + kx][1] +=
+                    Y1[i][m + kx][1] +=
                         sbr->s_m[e][m] * (phi[1][indexsine] * phi_sign);
                     phi_sign = -phi_sign;
                 }
@@ -1737,12 +1737,17 @@ void ff_sbr_apply(AACContext *ac, SpectralBandReplication *sbr, int id_aac,
             sbr_mapping(ac, sbr, &sbr->data[ch], sbr->data[ch].e_a);
             sbr_env_estimate(sbr->e_curr, sbr->X_high, sbr, &sbr->data[ch]);
             sbr_gain_calc(ac, sbr, &sbr->data[ch], sbr->data[ch].e_a);
-            sbr_hf_assemble(sbr->data[ch].Y, sbr->X_high, sbr, &sbr->data[ch],
+            sbr->data[ch].Ypos ^= 1;
+            sbr_hf_assemble(sbr->data[ch].Y[sbr->data[ch].Ypos],
+                            sbr->X_high, sbr, &sbr->data[ch],
                             sbr->data[ch].e_a);
         }
 
         /* synthesis */
-        sbr_x_gen(sbr, sbr->X[ch], sbr->X_low, sbr->data[ch].Y, ch);
+        sbr_x_gen(sbr, sbr->X[ch],
+                  sbr->data[ch].Y[1-sbr->data[ch].Ypos],
+                  sbr->data[ch].Y[  sbr->data[ch].Ypos],
+                  sbr->X_low, ch);
     }
 
     if (ac->m4ac.ps == 1) {
diff --git a/gst-libs/ext/libav/libavcodec/sbr.h b/gst-libs/ext/libav/libavcodec/sbr.h
index 7d06fad..8da8e57 100644
--- a/gst-libs/ext/libav/libavcodec/sbr.h
+++ b/gst-libs/ext/libav/libavcodec/sbr.h
@@ -87,6 +87,7 @@ typedef struct {
     ///QMF values of the original signal
     float              W[2][32][32][2];
     ///QMF output of the HF adjustor
+    int                Ypos;
     float              Y[2][38][64][2];
     float              g_temp[42][48];
     float              q_temp[42][48];
-- 
1.7.9.5

