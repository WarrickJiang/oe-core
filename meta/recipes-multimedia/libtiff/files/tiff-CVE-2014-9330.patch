Upstream-Status: Backport

Signed-off-by: Yue Tao <yue.tao@windriver.com>

Index: libtiff/tif_dir.c
===================================================================
RCS file: /cvs/maptools/cvsroot/libtiff/libtiff/tif_dir.c,v
retrieving revision 1.117
retrieving revision 1.118
diff -u -r1.117 -r1.118
--- a/libtiff/tif_dir.c	20 Nov 2014 16:47:21 -0000	1.117
+++ b/libtiff/tif_dir.c	21 Dec 2014 15:15:31 -0000	1.118
@@ -160,6 +160,7 @@ _TIFFVSetField(TIFF* tif, uint32 tag, va_list ap)
 	TIFFDirectory* td = &tif->tif_dir;
 	int status = 1;
 	uint32 v32, i, v;
+	double dblval;
 	char* s;
 	const TIFFField *fip = TIFFFindField(tif, tag, TIFF_ANY);
 	uint32 standard_tag = tag;
@@ -283,10 +284,16 @@ _TIFFVSetField(TIFF* tif, uint32 tag, va_list ap)
 			setDoubleArrayOneValue(&td->td_smaxsamplevalue, va_arg(ap, double), td->td_samplesperpixel);
 		break;
 	case TIFFTAG_XRESOLUTION:
-		td->td_xresolution = (float) va_arg(ap, double);
+		dblval = va_arg(ap, double);
+		if( dblval < 0 )
+			goto badvaluedouble;
+		td->td_xresolution = (float) dblval;
 		break;
 	case TIFFTAG_YRESOLUTION:
-		td->td_yresolution = (float) va_arg(ap, double);
+		dblval = va_arg(ap, double);
+		if( dblval < 0 )
+			goto badvaluedouble;
+		td->td_yresolution = (float) dblval;
 		break;
 	case TIFFTAG_PLANARCONFIG:
 		v = (uint16) va_arg(ap, uint16_vap);
@@ -693,6 +700,16 @@ badvalue32:
 		va_end(ap);
         }
 	return (0);
+badvaluedouble:
+	{
+	const TIFFField* fip=TIFFFieldWithTag(tif,tag);
+	TIFFErrorExt(tif->tif_clientdata, module,
+	     "%s: Bad value %f for \"%s\" tag",
+	     tif->tif_name, dblval,
+	     fip ? fip->field_name : "Unknown");
+	va_end(ap);
+	}
+	return (0);
 }
 
 /*
Index: libtiff/tif_dirread.c
===================================================================
RCS file: /cvs/maptools/cvsroot/libtiff/libtiff/tif_dirread.c,v
retrieving revision 1.180
retrieving revision 1.181
diff -u -r1.180 -r1.181
--- a/libtiff/tif_dirread.c	20 Nov 2014 16:47:21 -0000	1.180
+++ b/libtiff/tif_dirread.c	21 Dec 2014 15:15:31 -0000	1.181
@@ -3430,6 +3430,8 @@ TIFFReadDirectory(TIFF* tif)
 	const TIFFField* fip;
 	uint32 fii=FAILED_FII;
         toff_t nextdiroff;
+	int bitspersample_read = FALSE;
+
 	tif->tif_diroff=tif->tif_nextdiroff;
 	if (!TIFFCheckDirOffset(tif,tif->tif_nextdiroff))
 		return 0;           /* last offset or bad offset (IFD looping) */
@@ -3706,6 +3708,8 @@ TIFFReadDirectory(TIFF* tif)
 					}
 					if (!TIFFSetField(tif,dp->tdir_tag,value))
 						goto bad;
+					if( dp->tdir_tag == TIFFTAG_BITSPERSAMPLE )
+						bitspersample_read = TRUE;
 				}
 				break;
 			case TIFFTAG_SMINSAMPLEVALUE:
@@ -3763,6 +3767,19 @@ TIFFReadDirectory(TIFF* tif)
 					uint32 countrequired;
 					uint32 incrementpersample;
 					uint16* value=NULL;
+					/* It would be dangerous to instanciate those tag values */
+					/* since if td_bitspersample has not yet been read (due to */
+					/* unordered tags), it could be read afterwards with a */
+					/* values greater than the default one (1), which may cause */
+					/* crashes in user code */
+					if( !bitspersample_read )
+					{
+						fip = TIFFFieldWithTag(tif,dp->tdir_tag);
+						TIFFWarningExt(tif->tif_clientdata,module,
+							"Ignoring %s since BitsPerSample tag not found",
+							fip ? fip->field_name : "unknown tagname");
+						continue;
+					}
 					countpersample=(1L<<tif->tif_dir.td_bitspersample);
 					if ((dp->tdir_tag==TIFFTAG_TRANSFERFUNCTION)&&(dp->tdir_count==(uint64)countpersample))
 					{
Index: libtiff/tif_getimage.c
===================================================================
RCS file: /cvs/maptools/cvsroot/libtiff/libtiff/tif_getimage.c,v
retrieving revision 1.82
retrieving revision 1.83
diff -u -r1.82 -r1.83
--- a/libtiff/tif_getimage.c	6 Jun 2012 00:17:49 -0000	1.82
+++ b/libtiff/tif_getimage.c	21 Dec 2014 15:15:31 -0000	1.83
@@ -182,8 +182,23 @@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
 				    "Planarconfiguration", td->td_planarconfig);
 				return (0);
 			}
+			if( td->td_samplesperpixel != 3 )
+			{
+				sprintf(emsg,
+					"Sorry, can not handle image with %s=%d",
+					"Samples/pixel", td->td_samplesperpixel);
+				return 0;
+			}
 			break;
 		case PHOTOMETRIC_CIELAB:
+			if( td->td_samplesperpixel != 3 || td->td_bitspersample != 8 )
+			{
+				sprintf(emsg,
+					"Sorry, can not handle image with %s=%d and %s=%d",
+					"Samples/pixel", td->td_samplesperpixel,
+					"Bits/sample", td->td_bitspersample);
+				return 0;
+			}
 			break;
 		default:
 			sprintf(emsg, "Sorry, can not handle image with %s=%d",
Index: libtiff/tif_next.c
===================================================================
RCS file: /cvs/maptools/cvsroot/libtiff/libtiff/tif_next.c,v
retrieving revision 1.13
retrieving revision 1.14
diff -u -r1.13 -r1.14
--- a/libtiff/tif_next.c	10 Mar 2010 18:56:48 -0000	1.13
+++ b/libtiff/tif_next.c	21 Dec 2014 15:15:32 -0000	1.14
@@ -102,6 +102,8 @@ NeXTDecode(TIFF* tif, uint8* buf, tmsize_t occ, uint16 s)
 		default: {
 			uint32 npixels = 0, grey;
 			uint32 imagewidth = tif->tif_dir.td_imagewidth;
+			if( isTiled(tif) )
+				imagewidth = tif->tif_dir.td_tilewidth;
 
 			/*
 			 * The scanline is composed of a sequence of constant
Index: tools/bmp2tiff.c
===================================================================
RCS file: /cvs/maptools/cvsroot/libtiff/tools/bmp2tiff.c,v
retrieving revision 1.23
retrieving revision 1.24
diff -u -r1.23 -r1.24
--- a/tools/bmp2tiff.c	10 Mar 2010 18:56:49 -0000	1.23
+++ b/tools/bmp2tiff.c	21 Dec 2014 15:15:32 -0000	1.24
@@ -403,6 +403,13 @@ main(int argc, char* argv[])
 
 		width = info_hdr.iWidth;
 		length = (info_hdr.iHeight > 0) ? info_hdr.iHeight : -info_hdr.iHeight;
+		if( width <= 0 || length <= 0 )
+		{
+			TIFFError(infilename,
+				"Invalid dimensions of BMP file" );
+			close(fd);
+			return -1;
+		}
 
 		switch (info_hdr.iBitCount)
 		{
@@ -593,6 +600,14 @@ main(int argc, char* argv[])
 
 			compr_size = file_hdr.iSize - file_hdr.iOffBits;
 			uncompr_size = width * length;
+			/* Detect int overflow */
+			if( uncompr_size / width != length )
+			{
+				TIFFError(infilename,
+					"Invalid dimensions of BMP file" );
+				close(fd);
+				return -1;
+			}
 			comprbuf = (unsigned char *) _TIFFmalloc( compr_size );
 			if (!comprbuf) {
 				TIFFError(infilename,
Index: tools/tiff2pdf.c
===================================================================
RCS file: /cvs/maptools/cvsroot/libtiff/tools/tiff2pdf.c,v
retrieving revision 1.77
retrieving revision 1.78
diff -u -r1.77 -r1.78
--- a/tools/tiff2pdf.c	10 Dec 2014 02:53:30 -0000	1.77
+++ b/tools/tiff2pdf.c	21 Dec 2014 15:15:32 -0000	1.78
@@ -1165,6 +1165,15 @@ void t2p_read_tiff_init(T2P* t2p, TIFF* input){
 		if( (TIFFGetField(input, TIFFTAG_PLANARCONFIG, &xuint16) != 0)
 			&& (xuint16 == PLANARCONFIG_SEPARATE ) ){
 				TIFFGetField(input, TIFFTAG_SAMPLESPERPIXEL, &xuint16);
+			if( (t2p->tiff_tiles[i].tiles_tilecount % xuint16) != 0 )
+			{
+				TIFFError(
+					TIFF2PDF_MODULE, 
+					"Invalid tile count, %s", 
+					TIFFFileName(input));
+					t2p->t2p_error = T2P_ERR_ERROR;
+				return;
+			}
 				t2p->tiff_tiles[i].tiles_tilecount/= xuint16;
 		}
 		if( t2p->tiff_tiles[i].tiles_tilecount > 0){
@@ -1545,6 +1554,22 @@ void t2p_read_tiff_data(T2P* t2p, TIFF* input){
 #endif
 			break;
 		case PHOTOMETRIC_CIELAB:
+			if( t2p->tiff_samplesperpixel != 3){
+				TIFFError(
+					TIFF2PDF_MODULE, 
+					"Unsupported samplesperpixel = %d for CIELAB", 
+					t2p->tiff_samplesperpixel);
+				t2p->t2p_error = T2P_ERR_ERROR;
+				return;
+			}
+			if( t2p->tiff_bitspersample != 8){
+				TIFFError(
+					TIFF2PDF_MODULE, 
+					"Invalid bitspersample = %d for CIELAB", 
+					t2p->tiff_bitspersample);
+				t2p->t2p_error = T2P_ERR_ERROR;
+				return;
+			}
 			t2p->pdf_labrange[0]= -127;
 			t2p->pdf_labrange[1]= 127;
 			t2p->pdf_labrange[2]= -127;
@@ -1560,6 +1585,22 @@ void t2p_read_tiff_data(T2P* t2p, TIFF* input){
 			t2p->pdf_colorspace=T2P_CS_LAB;
 			break;
 		case PHOTOMETRIC_ITULAB:
+			if( t2p->tiff_samplesperpixel != 3){
+				TIFFError(
+					TIFF2PDF_MODULE, 
+					"Unsupported samplesperpixel = %d for ITULAB", 
+					t2p->tiff_samplesperpixel);
+				t2p->t2p_error = T2P_ERR_ERROR;
+				return;
+			}
+			if( t2p->tiff_bitspersample != 8){
+				TIFFError(
+					TIFF2PDF_MODULE, 
+					"Invalid bitspersample = %d for ITULAB", 
+					t2p->tiff_bitspersample);
+				t2p->t2p_error = T2P_ERR_ERROR;
+				return;
+			}
 			t2p->pdf_labrange[0]=-85;
 			t2p->pdf_labrange[1]=85;
 			t2p->pdf_labrange[2]=-75;
Index: tools/tiffcrop.c
===================================================================
RCS file: /cvs/maptools/cvsroot/libtiff/tools/tiffcrop.c,v
retrieving revision 1.23
retrieving revision 1.24
diff -u -r1.23 -r1.24
--- a/tools/tiffcrop.c	7 Dec 2014 22:33:06 -0000	1.23
+++ b/tools/tiffcrop.c	21 Dec 2014 15:15:32 -0000	1.24
@@ -1205,9 +1205,10 @@ static int writeBufferToContigTiles (TIFF* out, uint8* buf, uint32 imagelength,
   tsize_t tilesize = TIFFTileSize(out);
   unsigned char *tilebuf = NULL;
 
-  TIFFGetField(out, TIFFTAG_TILELENGTH, &tl);
-  TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw);
-  TIFFGetField(out, TIFFTAG_BITSPERSAMPLE, &bps);
+  if( !TIFFGetField(out, TIFFTAG_TILELENGTH, &tl) ||
+      !TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw) ||
+      !TIFFGetField(out, TIFFTAG_BITSPERSAMPLE, &bps) )
+      return 1;
 
   tile_buffsize = tilesize;
   if (tilesize < (tsize_t)(tl * tile_rowsize))
Index: tools/tiffdump.c
===================================================================
RCS file: /cvs/maptools/cvsroot/libtiff/tools/tiffdump.c,v
retrieving revision 1.28
retrieving revision 1.29
diff -u -r1.28 -r1.29
--- a/tools/tiffdump.c	6 Dec 2014 15:58:44 -0000	1.28
+++ b/tools/tiffdump.c	21 Dec 2014 15:15:32 -0000	1.29
@@ -355,6 +355,8 @@ ReadDirectory(int fd, unsigned int ix, uint64 off)
 		void* datamem;
 		uint64 dataoffset;
 		int datatruncated;
+		int datasizeoverflow;
+
 		tag = *(uint16*)dp;
 		if (swabflag)
 			TIFFSwabShort(&tag);
@@ -393,13 +395,14 @@ ReadDirectory(int fd, unsigned int ix, uint64 off)
 		else
 			typewidth = datawidth[type];
 		datasize = count*typewidth;
+		datasizeoverflow = (typewidth > 0 && datasize / typewidth != count);
 		datafits = 1;
 		datamem = dp;
 		dataoffset = 0;
 		datatruncated = 0;
 		if (!bigtiff)
 		{
-			if (datasize>4)
+			if (datasizeoverflow || datasize>4)
 			{
 				uint32 dataoffset32;
 				datafits = 0;
@@ -413,7 +416,7 @@ ReadDirectory(int fd, unsigned int ix, uint64 off)
 		}
 		else
 		{
-			if (datasize>8)
+			if (datasizeoverflow || datasize>8)
 			{
 				datafits = 0;
 				datamem = NULL;
@@ -423,7 +426,7 @@ ReadDirectory(int fd, unsigned int ix, uint64 off)
 			}
 			dp += sizeof(uint64);
 		}
-		if (datasize>0x10000)
+		if (datasizeoverflow || datasize>0x10000)
 		{
 			datatruncated = 1;
 			count = 0x10000/typewidth;
