From 8833beef86f19d0c5e2cbdc0ce7d3d0b9db07b37 Mon Sep 17 00:00:00 2001
From: Paul Pluzhnikov <ppluzhnikov@google.com>
Date: Fri, 6 Feb 2015 00:30:42 -0500
Subject: [PATCH] CVE-2015-1472: wscanf allocates too little memory

BZ #16618

Under certain conditions wscanf can allocate too little memory for the
to-be-scanned arguments and overflow the allocated buffer.  The
implementation now correctly computes the required buffer size when
using malloc.

A regression test was added to tst-sscanf.

Written by: Paul Pluzhnikov <ppluzhnikov@google.com>
Signed-off-by: Yuanjie Huang <Yuanjie.Huang@windriver.com>
---
 ChangeLog                 |    8 ++++++++
 NEWS                      |    7 ++++++-
 stdio-common/tst-sscanf.c |   33 +++++++++++++++++++++++++++++++++
 stdio-common/vfscanf.c    |   12 ++++++------
 4 files changed, 53 insertions(+), 7 deletions(-)

diff --git a/ChangeLog b/ChangeLog
index fe4dac3..735e2af 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,11 @@
+2015-02-05  Paul Pluzhnikov  <ppluzhnikov@google.com>
+
+	[BZ #16618]
+	* stdio-common/tst-sscanf.c (main): Test for buffer overflow.
+	* stdio-common/vfscanf.c (_IO_vfscanf_internal): Compute needed
+	size in bytes. Store needed elements in wpmax. Use needed size
+	in bytes for extend_alloca.
+
 2015-04-29  Florian Weimer  <fweimer@redhat.com>
 
 	[BZ #18007]
diff --git a/NEWS b/NEWS
index 0e43768..219ff6c 100644
--- a/NEWS
+++ b/NEWS
@@ -13,7 +13,7 @@ Version 2.20
   15698, 15804, 15894, 15946, 16002, 16064, 16095, 16194, 16198, 16275,
   16284, 16287, 16315, 16348, 16349, 16354, 16357, 16362, 16447, 16516,
   16532, 16539, 16545, 16561, 16562, 16564, 16574, 16599, 16600, 16609,
-  16610, 16611, 16613, 16617, 16619, 16623, 16629, 16632, 16634, 16639,
+  16610, 16611, 16613, 16617, 16618, 16619, 16623, 16629, 16632, 16634, 16639,
   16642, 16648, 16649, 16670, 16674, 16677, 16680, 16681, 16683, 16689,
   16695, 16701, 16706, 16707, 16712, 16713, 16714, 16724, 16731, 16739,
   16740, 16743, 16754, 16758, 16759, 16760, 16770, 16786, 16789, 16791,
@@ -26,6 +26,11 @@ Version 2.20
   17153, 17187, 17213, 17259, 17261, 17262, 17263, 17319, 17325, 17354,
   17625, 17630.
 
+* CVE-2015-1472 Under certain conditions wscanf can allocate too little
+  memory for the to-be-scanned arguments and overflow the allocated
+  buffer.  The implementation now correctly computes the required buffer
+  size when using malloc.
+
 * CVE-2104-7817 The wordexp function could ignore the WRDE_NOCMD flag
   under certain input conditions resulting in the execution of a shell for
   command substitution when the applicaiton did not request it. The
diff --git a/stdio-common/tst-sscanf.c b/stdio-common/tst-sscanf.c
index 9fef93a..6394fe1 100644
--- a/stdio-common/tst-sscanf.c
+++ b/stdio-common/tst-sscanf.c
@@ -233,5 +233,38 @@ main (void)
 	}
     }
 
+  /* BZ #16618
+     The test will segfault during SSCANF if the buffer overflow
+     is not fixed.  The size of `s` is such that it forces the use
+     of malloc internally and this triggers the incorrect computation.
+     Thus the value for SIZE is arbitrariy high enough that malloc
+     is used.  */
+  {
+#define SIZE 131072
+    CHAR *s = malloc ((SIZE + 1) * sizeof (*s));
+    if (s == NULL)
+      abort ();
+    for (size_t i = 0; i < SIZE; i++)
+      s[i] = L('0');
+    s[SIZE] = L('\0');
+    int i = 42;
+    /* Scan multi-digit zero into `i`.  */
+    if (SSCANF (s, L("%d"), &i) != 1)
+      {
+	printf ("FAIL: bug16618: SSCANF did not read one input item.\n");
+	result = 1;
+      }
+    if (i != 0)
+      {
+	printf ("FAIL: bug16618: Value of `i` was not zero as expected.\n");
+	result = 1;
+      }
+    free (s);
+    if (result != 1)
+      printf ("PASS: bug16618: Did not crash.\n");
+#undef SIZE
+  }
+
+
   return result;
 }
diff --git a/stdio-common/vfscanf.c b/stdio-common/vfscanf.c
index 4675628..c5fb49a 100644
--- a/stdio-common/vfscanf.c
+++ b/stdio-common/vfscanf.c
@@ -279,9 +279,10 @@ _IO_vfscanf_internal (_IO_FILE *s, const char *format, _IO_va_list argptr,
       if (__glibc_unlikely (wpsize == wpmax))				      \
 	{								    \
 	  CHAR_T *old = wp;						    \
-	  size_t newsize = (UCHAR_MAX + 1 > 2 * wpmax			    \
-			    ? UCHAR_MAX + 1 : 2 * wpmax);		    \
-	  if (use_malloc || !__libc_use_alloca (newsize))		    \
+	  bool fits = __glibc_likely (wpmax <= SIZE_MAX / sizeof (CHAR_T) / 2); \
+	  size_t wpneed = MAX (UCHAR_MAX + 1, 2 * wpmax);		    \
+	  size_t newsize = fits ? wpneed * sizeof (CHAR_T) : SIZE_MAX;	    \
+	  if (!__libc_use_alloca (newsize))				    \
 	    {								    \
 	      wp = realloc (use_malloc ? wp : NULL, newsize);		    \
 	      if (wp == NULL)						    \
@@ -293,14 +294,13 @@ _IO_vfscanf_internal (_IO_FILE *s, const char *format, _IO_va_list argptr,
 		}							    \
 	      if (! use_malloc)						    \
 		MEMCPY (wp, old, wpsize);				    \
-	      wpmax = newsize;						    \
+	      wpmax = wpneed;						    \
 	      use_malloc = true;					    \
 	    }								    \
 	  else								    \
 	    {								    \
 	      size_t s = wpmax * sizeof (CHAR_T);			    \
-	      wp = (CHAR_T *) extend_alloca (wp, s,			    \
-					     newsize * sizeof (CHAR_T));    \
+	      wp = (CHAR_T *) extend_alloca (wp, s, newsize);		    \
 	      wpmax = s / sizeof (CHAR_T);				    \
 	      if (old != NULL)						    \
 		MEMCPY (wp, old, wpsize);				    \
-- 
1.7.1

