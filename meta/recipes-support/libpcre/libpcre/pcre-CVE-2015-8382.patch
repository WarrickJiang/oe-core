r1510 | ph10 | 2014-11-05 23:08:03

Fix bug when there are unset groups prior to (*ACCEPT) within a capturing 
group.

Index: testdata/testinput1
===================================================================
--- a/testdata/testinput1	(revision 1509)
+++ b/testdata/testinput1	(revision 1510)
@@ -5720,4 +5720,7 @@
 /[\Q]a\E]+/
     aa]]
 
+/(?:((abcd))|(((?:(?:(?:(?:abc|(?:abcdef))))b)abcdefghi)abc)|((*ACCEPT)))/
+    1234abcd
+
 /-- End of testinput1 --/
Index: testdata/testoutput1
===================================================================
--- a/testdata/testoutput1	(revision 1509)
+++ b/testdata/testoutput1	(revision 1510)
@@ -9411,4 +9411,13 @@
     aa]]
  0: aa]]
 
+/(?:((abcd))|(((?:(?:(?:(?:abc|(?:abcdef))))b)abcdefghi)abc)|((*ACCEPT)))/
+    1234abcd
+ 0: 
+ 1: <unset>
+ 2: <unset>
+ 3: <unset>
+ 4: <unset>
+ 5: 
+
 /-- End of testinput1 --/
Index: pcre_exec.c
===================================================================
--- a/pcre_exec.c	(revision 1509)
+++ b/pcre_exec.c	(revision 1510)
@@ -1474,7 +1474,18 @@
       md->offset_vector[offset] =
         md->offset_vector[md->offset_end - number];
       md->offset_vector[offset+1] = (int)(eptr - md->start_subject);
-      if (offset_top <= offset) offset_top = offset + 2;
+
+      /* If this group is at or above the current highwater mark, ensure that
+      any groups between the current high water mark and this group are marked
+      unset and then update the high water mark. */
+
+      if (offset >= offset_top)
+        {
+        register int *iptr = md->offset_vector + offset_top;
+        register int *iend = md->offset_vector + offset;
+        while (iptr < iend) *iptr++ = -1;
+        offset_top = offset + 2;
+        }
       }
     ecode += 1 + IMM2_SIZE;
     break;
Index: ChangeLog
===================================================================
--- a/ChangeLog	(revision 1509)
+++ b/ChangeLog	(revision 1510)
@@ -1,5 +1,16 @@
 ChangeLog for PCRE
 ------------------
+
+Version 8.37 xx-xxx-201x
+------------------------
+
+1.  When an (*ACCEPT) is triggered inside capturing parentheses, it arranges 
+    for those parentheses to be closed with whatever has been captured so far. 
+    However, it was failing to mark any other groups between the hightest 
+    capture so far and the currrent group as "unset". Thus, the ovector for 
+    those groups contained whatever was previously there. An example is the 
+    pattern /(x)|((*ACCEPT))/ when matched against "abcd".
+
     
 19. Incorrect code was compiled if a group that contained an internal recursive 
     back reference was optional (had quantifier with a minimum of zero). This
