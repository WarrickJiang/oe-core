Description: CVE-2015-1197
 Apply patch by Vitezslav Cizek of SuSE to fix CVE-2015-1197.
 Upstream is dormant or no longer existing. To restore the old
 behaviour use --extract-over-symlinks (Closes: #774669)
 This issue has been discovered by Alexander Cherepanov.
Author: Vitezslav Cizek <vcizek@suse.cz>
Bug-Debian: https://bugs.debian.org/774669

Upstream-Status: Backport+cpio: CVE-2015-1197

Signed-off-by: Robert Yang <liezhi.yang@windriver.com>

---
 doc/cpio.1   |  1 +
 src/copyin.c | 62 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 src/extern.h |  1 +
 src/global.c |  3 +++
 src/main.c   |  9 ++++++++-
 5 files changed, 75 insertions(+), 1 deletion(-)

diff --git a/doc/cpio.1 b/doc/cpio.1
index c18cfb4..74fe783 100644
--- a/doc/cpio.1
+++ b/doc/cpio.1
@@ -22,6 +22,7 @@ cpio \- copy files to and from archives
 [\-\-owner=[user][:.][group]] [\-\-no-preserve-owner] [\-\-message=message]
 [\-\-force\-local] [\-\-no\-absolute\-filenames] [\-\-sparse]
 [\-\-only\-verify\-crc] [\-\-to\-stdout] [\-\-quiet] [\-\-rsh-command=command]
+[\-\-extract\-over\-symlinks]
 [\-\-help] [\-\-version] [pattern...] [< archive]
 
 .B cpio
diff --git a/src/copyin.c b/src/copyin.c
index aec042e..15c9daa 100644
--- a/src/copyin.c
+++ b/src/copyin.c
@@ -656,6 +656,51 @@ copyin_device (struct cpio_file_stat* file_hdr)
 		    file_hdr->c_mtime);
 }
 
+
+static int
+path_contains_symlink(char *path)
+{
+  struct stat st;
+  char *slash;
+  char *nextslash;
+
+  /* we got NULL pointer or empty string */
+  if (!path || !*path) {
+    return false;
+  }
+
+  slash = path;
+
+  while ((nextslash = strchr(slash + 1, '/')) != NULL) {
+    slash = nextslash;
+    *slash = '\0';
+
+    if (lstat(path, &st) != 0) {
+      if (errno == ELOOP) {
+        /* ELOOP - too many symlinks */
+        *slash = '/';
+        return true;
+      } else if (errno == ENOMEM) {
+        /* No memory for lstat - terminate */
+        xalloc_die();
+      } else {
+        /* cannot lstat path - give up */
+        *slash = '/';
+        return false;
+      }
+    }
+
+    if (S_ISLNK(st.st_mode)) {
+      *slash = '/';
+      return true;
+    }
+
+    *slash = '/';
+  }
+
+  return false;
+}
+
 static void
 copyin_link(struct cpio_file_stat *file_hdr, int in_file_des)
 {
@@ -1471,6 +1516,23 @@ process_copy_in ()
 	{
 	  /* Copy the input file into the directory structure.  */
 
+          /* Can we write files over symlinks? */
+          if (!extract_over_symlinks)
+            {
+              if (path_contains_symlink(file_hdr.c_name))
+                {
+                  /* skip the file */
+                  /*
+                  fprintf(stderr, "Can't write over symlinks. Skipping %s\n", file_hdr.c_name);
+                  tape_toss_input (in_file_des, file_hdr.c_filesize);
+                  tape_skip_padding (in_file_des, file_hdr.c_filesize);
+                  continue;
+                  */
+                  /* terminate */
+	          error (1, 0, _("Can't write over symlinks: %s\n"), file_hdr.c_name);
+                }
+            }
+
 	  /* Do we need to rename the file? */
 	  if (rename_flag || rename_batch_file)
 	    {
diff --git a/src/extern.h b/src/extern.h
index 4f94d40..7c24219 100644
--- a/src/extern.h
+++ b/src/extern.h
@@ -95,6 +95,7 @@ extern char input_is_special;
 extern char output_is_special;
 extern char input_is_seekable;
 extern char output_is_seekable;
+extern bool extract_over_symlinks;
 extern int (*xstat) ();
 extern void (*copy_function) ();
 
diff --git a/src/global.c b/src/global.c
index cff9720..3074ec1 100644
--- a/src/global.c
+++ b/src/global.c
@@ -187,6 +187,9 @@ bool to_stdout_option = false;
 /* The name this program was run with.  */
 char *program_name;
 
+/* Extract files over symbolic links */
+bool extract_over_symlinks;
+
 /* A pointer to either lstat or stat, depending on whether
    dereferencing of symlinks is done for input files.  */
 int (*xstat) ();
diff --git a/src/main.c b/src/main.c
index ba1b969..f0197ef 100644
--- a/src/main.c
+++ b/src/main.c
@@ -57,7 +57,8 @@ enum cpio_options {
   FORCE_LOCAL_OPTION,            
   DEBUG_OPTION,                  
   BLOCK_SIZE_OPTION,             
-  TO_STDOUT_OPTION
+  TO_STDOUT_OPTION,
+  EXTRACT_OVER_SYMLINKS
 };
 
 const char *program_authors[] =
@@ -222,6 +223,8 @@ static struct argp_option options[] = {
    N_("Create leading directories where needed"), GRID+1 },
   {"no-preserve-owner", NO_PRESERVE_OWNER_OPTION, 0, 0,
    N_("Do not change the ownership of the files"), GRID+1 },
+  {"extract-over-symlinks", EXTRACT_OVER_SYMLINKS, 0, 0,
+   N_("Force writing over symbolic links"), GRID+1 },
   {"unconditional", 'u', NULL, 0,
    N_("Replace all files unconditionally"), GRID+1 },
   {"sparse", SPARSE_OPTION, NULL, 0,
@@ -412,6 +415,10 @@ crc newc odc bin ustar tar (all-caps also recognized)"), arg);
       no_chown_flag = true;
       break;
 
+    case EXTRACT_OVER_SYMLINKS:		        /* --extract-over-symlinks */
+      extract_over_symlinks = true;
+      break;
+
     case 'o':		/* Copy-out mode.  */
       if (copy_function != 0)
 	error (PAXEXIT_FAILURE, 0, _("Mode already defined"));
-- 
1.8.5.2.233.g932f7e4

