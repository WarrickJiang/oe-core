From 427120b41a141626dbb40a752c848f199fc9f7a8 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Stefan=20B=C3=BChler?= <stbuehler@web.de>
Date: Thu, 28 May 2015 15:47:14 +0000
Subject: [PATCH] =?UTF-8?q?escape=20all=20strings=20for=20logging=20(fixes=20?=
 =?UTF-8?q?#2646=20log=20file=20injection,=20reported=20by=20Jaanus=20K=C3=A4?=
 =?UTF-8?q?=C3=A4p)?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

From: Stefan BÃ¼hler <stbuehler@web.de>

git-svn-id: svn://svn.lighttpd.net/lighttpd/branches/lighttpd-1.4.x@2989 152afb58-edef-0310-8abb-c4023f1b3aa9
---
 src/buffer.c |   59 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 src/buffer.h |    5 ++++-
 src/log.c    |    8 ++++----
 4 files changed, 70 insertions(+), 7 deletions(-)

diff --git a/src/buffer.c b/src/buffer.c
index 57c1613..36995a0 100644
--- a/src/buffer.c
+++ b/src/buffer.c
@@ -76,6 +76,41 @@ void buffer_reset(buffer *b) {
  */
 
 #define BUFFER_PIECE_SIZE 64
+static size_t buffer_align_size(size_t size) {
+	size_t align = BUFFER_PIECE_SIZE - (size % BUFFER_PIECE_SIZE);
+	/* overflow on unsinged size_t is defined to wrap around */
+	if (size + align < size) return size;
+	return size + align;
+}
+
+/* make sure buffer is at least "size" big. discard old data */
+static void buffer_alloc(buffer *b, size_t size) {
+	force_assert(NULL != b);
+	if (0 == size) size = 1;
+
+	if (size <= b->size) return;
+
+	if (NULL != b->ptr) free(b->ptr);
+
+	b->used = 0;
+	b->size = buffer_align_size(size);
+	b->ptr = malloc(b->size);
+
+	force_assert(NULL != b->ptr);
+}
+
+/* make sure buffer is at least "size" big. keep old data */
+static void buffer_realloc(buffer *b, size_t size) {
+	force_assert(NULL != b);
+	if (0 == size) size = 1;
+
+	if (size <= b->size) return;
+
+	b->size = buffer_align_size(size);
+	b->ptr = realloc(b->ptr, b->size);
+
+	force_assert(NULL != b->ptr);
+}
 
 int buffer_prepare_copy(buffer *b, size_t size) {
 	if (!b) return -1;
@@ -96,6 +131,24 @@ int buffer_prepare_copy(buffer *b, size_t size) {
 	return 0;
 }
 
+void buffer_commit(buffer *b, size_t size)
+{
+	force_assert(NULL != b);
+	force_assert(b->size > 0);
+
+	if (0 == b->used) b->used = 1;
+
+	if (size > 0) {
+		/* check for overflow: unsigned overflow is defined to wrap around */
+		force_assert(b->used + size > b->used);
+
+		force_assert(b->used + size <= b->size);
+		b->used += size;
+	}
+
+	b->ptr[b->used - 1] = '\0';
+}
+
 /**
  *
  * increase the internal buffer (if neccessary) to append another 'size' byte
@@ -853,6 +906,100 @@ int buffer_append_string_encoded(buffer *b, const char *s, size_t s_len, buffer_
 	return 0;
 }
 
+int buffer_string_is_empty(const buffer *b) {
+	return 0 == buffer_string_length(b);
+}
+
+char* buffer_string_prepare_copy(buffer *b, size_t size) {
+	force_assert(NULL != b);
+	force_assert(size + 1 > size);
+
+	buffer_alloc(b, size + 1);
+
+	b->used = 1;
+	b->ptr[0] = '\0';
+
+	return b->ptr;
+}
+
+char* buffer_string_prepare_append(buffer *b, size_t size) {
+	force_assert(NULL !=  b);
+
+	if (buffer_string_is_empty(b)) {
+		return buffer_string_prepare_copy(b, size);
+	} else {
+		size_t req_size = b->used + size;
+
+		/* not empty, b->used already includes a terminating 0 */
+		force_assert(req_size >= b->used);
+
+		/* check for overflow: unsigned overflow is defined to wrap around */
+		force_assert(req_size >= b->used);
+
+		buffer_realloc(b, req_size);
+
+		return b->ptr + b->used - 1;
+	}
+}
+
+void buffer_append_string_c_escaped(buffer *b, const char *s, size_t s_len) {
+	unsigned char *ds, *d;
+	size_t d_len, ndx;
+
+	force_assert(NULL != b);
+	force_assert(NULL != s || 0 == s_len);
+
+	if (0 == s_len) return;
+
+	/* count to-be-encoded-characters */
+	for (ds = (unsigned char *)s, d_len = 0, ndx = 0; ndx < s_len; ds++, ndx++) {
+		if ((*ds < 0x20) /* control character */
+				|| (*ds >= 0x7f)) { /* DEL + non-ASCII characters */
+			switch (*ds) {
+			case '\t':
+			case '\r':
+			case '\n':
+				d_len += 2;
+				break;
+			default:
+				d_len += 4; /* \xCC */
+				break;
+			}
+		} else {
+			d_len++;
+		}
+	}
+
+	d = (unsigned char*) buffer_string_prepare_append(b, d_len);
+	buffer_commit(b, d_len); /* fill below */
+	force_assert('\0' == *d);
+
+	for (ds = (unsigned char *)s, d_len = 0, ndx = 0; ndx < s_len; ds++, ndx++) {
+		if ((*ds < 0x20) /* control character */
+				|| (*ds >= 0x7f)) { /* DEL + non-ASCII characters */
+			d[d_len++] = '\\';
+			switch (*ds) {
+			case '\t':
+				d[d_len++] = 't';
+				break;
+			case '\r':
+				d[d_len++] = 'r';
+				break;
+			case '\n':
+				d[d_len++] = 'n';
+				break;
+			default:
+				d[d_len++] = 'x';
+				d[d_len++] = hex_chars[((*ds) >> 4) & 0x0F];
+				d[d_len++] = hex_chars[(*ds) & 0x0F];
+				break;
+			}
+		} else {
+			d[d_len++] = *ds;
+		}
+	}
+}
+
 
 /* decodes url-special-chars inplace.
  * replaces non-printable characters with '_'
diff --git a/src/buffer.h b/src/buffer.h
index b6065d4..5f659df 100644
--- a/src/buffer.h
+++ b/src/buffer.h
@@ -46,6 +46,8 @@ void buffer_reset(buffer *b);
 
 int buffer_prepare_copy(buffer *b, size_t size);
 int buffer_prepare_append(buffer *b, size_t size);
+char* buffer_string_prepare_copy(buffer *b, size_t size);
+char* buffer_string_prepare_append(buffer *b, size_t size);
 
 int buffer_copy_string(buffer *b, const char *s);
 int buffer_copy_string_len(buffer *b, const char *s, size_t s_len);
@@ -78,6 +80,8 @@ int buffer_append_memory(buffer *b, const char *s, size_t s_len);
 char * buffer_search_string_len(buffer *b, const char *needle, size_t len);
 
 int buffer_is_empty(buffer *b);
+/* NULL buffer, empty buffer (used == 0) or empty string (used == 1) */
+int buffer_string_is_empty(const buffer *b);
 int buffer_is_equal(buffer *a, buffer *b);
 int buffer_is_equal_right_len(buffer *a, buffer *b, size_t len);
 int buffer_is_equal_string(buffer *a, const char *s, size_t b_len);
@@ -96,6 +100,9 @@ typedef enum {
 
 int buffer_append_string_encoded(buffer *b, const char *s, size_t s_len, buffer_encoding_t encoding);
 
+/* escape non-printable characters; simple escapes for \t, \r, \n; fallback to \xCC */
+void buffer_append_string_c_escaped(buffer *b, const char *s, size_t s_len);
+
 int buffer_urldecode_path(buffer *url);
 int buffer_urldecode_query(buffer *url);
 int buffer_path_simplify(buffer *dest, buffer *src);
@@ -113,6 +120,8 @@ int light_isxdigit(int c);
 int light_isalpha(int c);
 int light_isalnum(int c);
 
+static inline size_t buffer_string_length(const buffer *b); /* buffer string length without terminating 0 */
+
 #define BUFFER_APPEND_STRING_CONST(x, y) \
 	buffer_append_string_len(x, y, sizeof(y) - 1)
 
@@ -123,8 +132,11 @@ int light_isalnum(int c);
 	if (x->used > 1 && x->ptr[x->used - 2] != '/') { BUFFER_APPEND_STRING_CONST(x, "/"); }
 
 #define CONST_STR_LEN(x) x, x ? sizeof(x) - 1 : 0
-#define CONST_BUF_LEN(x) x->ptr, x->used ? x->used - 1 : 0
+#define CONST_BUF_LEN(x) ((x) ? (x)->ptr : NULL), x->used ? x->used - 1 : 0
 
+static inline size_t buffer_string_length(const buffer *b) {
+	return NULL != b && 0 != b->used ? b->used - 1 : 0;
+}
 
 #define UNUSED(x) ( (void)(x) )
 
diff --git a/src/log.c b/src/log.c
index 9322d2c..94f4710 100644
--- a/src/log.c
+++ b/src/log.c
@@ -267,12 +267,12 @@ static void log_buffer_append_printf(buffer *out, const char *fmt, va_list ap) {
 		switch(*fmt) {
 		case 's':           /* string */
 			s = va_arg(ap, char *);
-			buffer_append_string(out, s);
+			buffer_append_string_c_escaped(out, s, (NULL != s) ? strlen(s) : 0);
 			buffer_append_string_len(out, CONST_STR_LEN(" "));
 			break;
 		case 'b':           /* buffer */
 			b = va_arg(ap, buffer *);
-			buffer_append_string_buffer(out, b);
+			buffer_append_string_c_escaped(out, CONST_BUF_LEN(b));
 			buffer_append_string_len(out, CONST_STR_LEN(" "));
 			break;
 		case 'd':           /* int */
@@ -293,11 +293,11 @@ static void log_buffer_append_printf(buffer *out, const char *fmt, va_list ap) {
 			break;
 		case 'S':           /* string */
 			s = va_arg(ap, char *);
-			buffer_append_string(out, s);
+			buffer_append_string_c_escaped(out, s, (NULL != s) ? strlen(s) : 0);
 			break;
 		case 'B':           /* buffer */
 			b = va_arg(ap, buffer *);
-			buffer_append_string_buffer(out, b);
+			buffer_append_string_c_escaped(out, CONST_BUF_LEN(b));
 			break;
 		case 'D':           /* int */
 			d = va_arg(ap, int);
-- 
1.7.9.5

