From d3542a276d2f2e529a17003e3159f72f5a18cfe6 Mon Sep 17 00:00:00 2001
From: Qualys Security Advisory <qsa@qualys.com>
Date: Thu, 1 Jan 1970 00:00:00 +0000
Subject: [PATCH 5/5] proc/alloc.*: Use size_t, not unsigned int.

commit f1077b7a558a5545837aae068422e58f1f9b1d33 upstream
https://gitlab.com/procps-ng/procps.git

Otherwise this can truncate sizes on 64-bit platforms, and is one of the
reasons the integer overflows in file2strvec() are exploitable at all.
Also: catch potential integer overflow in xstrdup() (should never
happen, but better safe than sorry), and use memcpy() instead of
strcpy() (faster).

Warnings:

- in glibc, realloc(ptr, 0) is equivalent to free(ptr), but not here,
  because of the ++size;

- here, xstrdup() can return NULL (if str is NULL), which goes against
  the idea of the xalloc wrappers.

We were tempted to call exit() or xerrx() in those cases, but decided
against it, because it might break things in unexpected places; TODO?

Upstream-Status: Backport
CVE: CVE-2018-1126

Signed-off-by: Zhang Xiao <xiao.zhang@windriver.com>
---
 proc/alloc.c | 20 ++++++++++++--------
 proc/alloc.h |  4 ++--
 2 files changed, 14 insertions(+), 10 deletions(-)

diff --git a/proc/alloc.c b/proc/alloc.c
index 94af47f..1768d73 100644
--- a/proc/alloc.c
+++ b/proc/alloc.c
@@ -37,14 +37,14 @@ static void xdefault_error(const char *restrict fmts, ...) {
 message_fn xalloc_err_handler = xdefault_error;
 
 
-void *xcalloc(unsigned int size) {
+void *xcalloc(size_t size) {
     void * p;
 
     if (size == 0)
         ++size;
     p = calloc(1, size);
     if (!p) {
-        xalloc_err_handler("%s failed to allocate %u bytes of memory", __func__, size);
+        xalloc_err_handler("%s failed to allocate %zu bytes of memory", __func__, size);
         exit(EXIT_FAILURE);
     }
     return p;
@@ -57,20 +57,20 @@ void *xmalloc(size_t size) {
         ++size;
     p = malloc(size);
     if (!p) {
-	xalloc_err_handler("%s failed to allocate %zu bytes of memory", __func__, size);
+        xalloc_err_handler("%s failed to allocate %zu bytes of memory", __func__, size);
         exit(EXIT_FAILURE);
     }
     return(p);
 }
 
-void *xrealloc(void *oldp, unsigned int size) {
+void *xrealloc(void *oldp, size_t size) {
     void *p;
 
     if (size == 0)
         ++size;
     p = realloc(oldp, size);
     if (!p) {
-        xalloc_err_handler("%s failed to allocate %u bytes of memory", __func__, size);
+        xalloc_err_handler("%s failed to allocate %zu bytes of memory", __func__, size);
         exit(EXIT_FAILURE);
     }
     return(p);
@@ -80,13 +80,17 @@ char *xstrdup(const char *str) {
     char *p = NULL;
 
     if (str) {
-        unsigned int size = strlen(str) + 1;
+        size_t size = strlen(str) + 1;
+        if (size < 1) {
+            xalloc_err_handler("%s refused to allocate %zu bytes of memory", __func__, size);
+            exit(EXIT_FAILURE);
+        }
         p = malloc(size);
         if (!p) {
-            xalloc_err_handler("%s failed to allocate %u bytes of memory", __func__, size);
+            xalloc_err_handler("%s failed to allocate %zu bytes of memory", __func__, size);
             exit(EXIT_FAILURE);
         }
-        strcpy(p, str);
+        memcpy(p, str, size);
     }
     return(p);
 }
diff --git a/proc/alloc.h b/proc/alloc.h
index 19c91d7..6787a72 100644
--- a/proc/alloc.h
+++ b/proc/alloc.h
@@ -8,9 +8,9 @@ EXTERN_C_BEGIN
  /* change xalloc_err_handler to override the default fprintf(stderr... */
 extern message_fn xalloc_err_handler;
 
-extern void *xcalloc(unsigned int size) MALLOC;
+extern void *xcalloc(size_t size) MALLOC;
 extern void *xmalloc(size_t size) MALLOC;
-extern void *xrealloc(void *oldp, unsigned int size) MALLOC;
+extern void *xrealloc(void *oldp, size_t size) MALLOC;
 extern char *xstrdup(const char *str) MALLOC;
 
 EXTERN_C_END
-- 
2.11.0

