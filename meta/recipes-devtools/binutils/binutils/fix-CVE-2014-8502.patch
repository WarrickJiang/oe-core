From 2bc3c3b116fca62013a354a966d8ebd03bef5b55 Mon Sep 17 00:00:00 2001
From: Prashant Purohit <prashant.purohit@kpit.com>
Date: Tue, 5 May 2015 10:01:31 +0000
Subject: [PATCH] Fix CVE-2014-8502

From 5a3f568b70bdfb91aacdfb66657b56d8c6d242f1 Mon Nov 3 17:44:00 2014 +0000
Author: Nick Clifton <nickc@redhat.com>
Date:   Mon Nov 3 17:44:00 2014 +0000
Subject: More fixes for buffer overruns instigated by corrupt binaries.

    	PR binutils/17512
    	* objdump.c (slurp_symtab): Fail gracefully if the table could not
    	be read.
    	(dump_relocs_in_section): Likewise.

    	* aoutx.h (slurp_symbol_table): Check that computed table size is
    	not bigger than the file from which is it being read.
    	(slurp_reloc_table): Likewise.
    	* coffcode.h (coff_slurp_line_table): Remove unneeded local
    	'warned'.  Do not try to print the details of a symbol with an
    	invalid index.
    	* coffgen.c (make_a_sectiobn_from_file): Check computed string
    	index against length of string table.
    	(bfd_coff_internal_syment_name): Check read in string offset
    	against length of string table.
    	(build_debug_section): Return a pointer to the section used.
    	(_bfd_coff_read_string_table): Store the length of the string
    	table in the coff_tdata structure.
    	(bfd_coff_free_symbols): Set the length of the string table to
    	zero when it is freed.
    	(coff_get_normalized_symtab): Check offsets against string table
    	or data table lengths as appropriate.
    	* cofflink.c (_bfd_coff_link_input_bfd): Check offset against
    	length of string table.
    	* compress.c (bfd_get_full_section_contents): Check computed size
    	against the size of the file.
    	* libcoff-in.h (obj_coff_strings_len): Define.
    	(struct coff_tdata): Add strings_len field.
    	* libcoff.h: Regenerate.
    	* peXXigen.c (pe_print_debugdata): Do not attempt to print the
    	data if the debug section is too small.
    	* xcofflink.c (xcoff_link_input_bfd):  Check offset against
    	length of string table.
------------------------------------------------------------------------
From 7e760b06b212f01b3819d5b37e8f5b613e0db34c Thu Oct 30 15:52:10 2014 +0000
Author: Nick Clifton <nickc@redhat.com>
Date:   Thu Oct 30 15:52:10 2014 +0000
Subject: Closes another memory corruption, this time due to heap overrun.

    	PR binutils/17512
    	* coffgen.c (coff_get_normalized_symtab): Prevent buffer overrun.
-----------------------------------------------------------------------
From f54498b45795194df671207c6ef3d6cd6d0c0ebb Fri Oct 31 16:36:31 2014 +0000
Author: Nick Clifton <nickc@redhat.com>
Date:   Fri Oct 31 16:36:31 2014 +0000
Subject: Avoid allocating over-large buffers when parsing corrupt binaries.

    	PR binutils/17512
    	* coffgen.c (_bfd_coff_get_external_symbols): Do not try to load a
    	symbol table bigger than the file.
-----------------------------------------------------------------------
From: bf67003b4567600ed3022a439207ac8f26454f91
Author: Nick Clifton <nickc@redhat.com>
Date: Mon, 27 Oct 2014 23:35:37 +0530 (18:05 +0000)
Subject: This fixes more seg-faults in tools like "strings" and "objdump" when
presented with corrupt binaries.

    	PR binutils/17512
    	* peXXigen.c (pe_print_edata): Detect out of range rvas and
    	entry counts for the Export Address table, Name Pointer table
    	and Ordinal table.
-----------------------------------------------------------------------
From: b2f93c5011cab00f31669363577b938697752e43
Author: Nick Clifton <nickc@redhat.com>
Date: Tue, 28 Oct 2014 16:20:17 +0530 (10:50 +0000)
Subject: Import patches from the master branch which prevent seg-faults
when parsing corrupt binaries.

    	* peXXigen.c (pe_print_edata): Detect out of range rvas and entry
    	 counts for the Export Address table, Name Pointer table and
    	 Ordinal table.
-----------------------------------------------------------------------
From: 5a4b0ccc20ba30caef53b01bee2c0aaa5b855339
Author: Nick Clifton <nickc@redhat.com>
Date: Tue, 28 Oct 2014 21:12:56 +0530 (15:42 +0000)

Subject: More fixes for corrupt binaries crashing the binutils.

    	PR binutils/17512
    	* peXXigen.c (pe_print_edata): Handle binaries with a truncated
    	export table.
-----------------------------------------------------------------------
From: 20ad5e2842911039a60b6bdf9880cee895179e43
Author: Nick Clifton <nickc@redhat.com>
Date: Wed, 5 Nov 2014 15:43:16 +0530 (10:13 +0000)
Subject: More fixes for processing corrupt files.

    	PR binutils/17512
    	* peXXigen.c (pe_print_idata): Add range checks.
    	(pe_print_edata): Likewise.
-----------------------------------------------------------------------
From: 201159ecec7e17600df4153e5d4e7a145f0c7cfe
Author: Nick Clifton <nickc@redhat.com>
Date: Tue, 11 Nov 2014 21:04:27 +0530 (15:34 +0000)
Subject: More fixes for invalid memory accesses, uncovered by valgrind
and binary fuzzers.

    	PR binutils/17512
    	* peXXigen.c (pe_print_edata): Avoid reading off the end of the
    	 data buffer.
-----------------------------------------------------------------------
From: 64d2901806c171c0d949f8fb1b29b4e5ba8cf04d
Author: Nick Clifton <nickc@redhat.com>
Date: Tue, 3 Feb 2015 20:04:54 +0530 (14:34 +0000)
Subject: More fixes for illegal memory accesses triggered by running
objdump on fuzzed binaries.

    	PR binutils/17512
    	* peXXigen.c (pe_print_edata):  Check for numeric overflow in edt
    	fields.

Summary of changes:
 bfd/peXXigen.c : Modified this file to fix segmentation fault in
                  'pe_print_edata' function.
-----------------------------------------------------------------------

Signed-off-by: Prashant Purohit <prashant.purohit@kpit.com>
Signed-off-by: Yuanjie Huang <Yuanjie.Huang@windriver.com>
---
 bfd/aoutx.h        |    7 ++++
 bfd/coffcode.h     |   39 +++++++++++++++++-------
 bfd/coffgen.c      |   82 +++++++++++++++++++++++++++++++++++++++------------
 bfd/compress.c     |    8 +++++
 bfd/elf.c          |   13 +++++++-
 bfd/libcoff-in.h   |    3 ++
 bfd/libcoff.h      |    3 ++
 bfd/peXXigen.c     |   73 ++++++++++++++++++++++++++++++++--------------
 bfd/xcofflink.c    |    5 ++-
 binutils/objdump.c |   11 ++++++-
 10 files changed, 186 insertions(+), 58 deletions(-)

diff --git a/bfd/aoutx.h b/bfd/aoutx.h
index 4db4788..38ee3fd 100644
--- a/bfd/aoutx.h
+++ b/bfd/aoutx.h
@@ -1753,6 +1753,8 @@ NAME (aout, slurp_symbol_table) (bfd *abfd)
     return TRUE;		/* Nothing to do.  */
 
   cached_size *= sizeof (aout_symbol_type);
+  if (cached_size >= (bfd_size_type) bfd_get_size (abfd))
+    return FALSE;
   cached = (aout_symbol_type *) bfd_zmalloc (cached_size);
   if (cached == NULL)
     return FALSE;
@@ -2304,6 +2306,11 @@ NAME (aout, slurp_reloc_table) (bfd *abfd, sec_ptr asect, asymbol **symbols)
   if (reloc_size == 0)
     return TRUE;		/* Nothing to be done.  */
 
+  /* PR binutils/17512: Do not even try to
+     load the relocs if their size is corrupt.  */
+  if (reloc_size + asect->rel_filepos >= (bfd_size_type) bfd_get_size (abfd))
+    return FALSE;
+
   if (bfd_seek (abfd, asect->rel_filepos, SEEK_SET) != 0)
     return FALSE;
 
diff --git a/bfd/coffcode.h b/bfd/coffcode.h
index 542b5b7..acdfbd4 100644
--- a/bfd/coffcode.h
+++ b/bfd/coffcode.h
@@ -1916,6 +1916,15 @@ coff_set_alignment_hook (bfd * abfd ATTRIBUTE_UNUSED,
       if (bfd_seek (abfd, oldpos, 0) != 0)
 	return;
       section->reloc_count = hdr->s_nreloc = n.r_vaddr - 1;
+      /* PR binutils/17512: Stop corrupt files from causing
+        memory problems if they claim to have too many relocs.  */
+      if (section->reloc_count * relsz > (bfd_size_type) bfd_get_size (abfd))
+       {
+         (*_bfd_error_handler)
+           ("%s: warning: claims to have %#x relocs, but the file is not that big",
+            bfd_get_filename (abfd), section->reloc_count);
+         section->reloc_count = 0;
+       }
       section->rel_filepos += relsz;
     }
   else if (hdr->s_nreloc == 0xffff)
@@ -4498,6 +4507,8 @@ coff_sort_func_alent (const void * arg1, const void * arg2)
   const coff_symbol_type *s1 = (const coff_symbol_type *) (al1->u.sym);
   const coff_symbol_type *s2 = (const coff_symbol_type *) (al2->u.sym);
 
+  if (s1 == NULL || s2 == NULL)
+    return 0;
   if (s1->symbol.value < s2->symbol.value)
     return -1;
   else if (s1->symbol.value > s2->symbol.value)
@@ -4522,7 +4533,9 @@ coff_slurp_line_table (bfd *abfd, asection *asect)
   BFD_ASSERT (asect->lineno == NULL);
 
   amt = ((bfd_size_type) asect->lineno_count + 1) * sizeof (alent);
-  lineno_cache = (alent *) bfd_alloc (abfd, amt);
+  if (amt > (bfd_size_type) bfd_get_size (abfd))
+    return FALSE;
+  lineno_cache = (alent *) bfd_zalloc (abfd, amt);
   if (lineno_cache == NULL)
     return FALSE;
 
@@ -4550,21 +4563,18 @@ coff_slurp_line_table (bfd *abfd, asection *asect)
 
       if (cache_ptr->line_number == 0)
 	{
-	  bfd_boolean warned;
 	  bfd_signed_vma symndx;
 	  coff_symbol_type *sym;
 
 	  nbr_func++;
-	  warned = FALSE;
 	  symndx = dst.l_addr.l_symndx;
 	  if (symndx < 0
 	      || (bfd_vma) symndx >= obj_raw_syment_count (abfd))
 	    {
 	      (*_bfd_error_handler)
-		(_("%B: warning: illegal symbol index %ld in line numbers"),
-		 abfd, (long) symndx);
-	      symndx = 0;
-	      warned = TRUE;
+	       (_("%B: warning: illegal symbol index 0x%lx in line number entry %d"),
+	       abfd, (long) symndx, counter);
+	      continue;
 	    }
 
 	  /* FIXME: We should not be casting between ints and
@@ -4573,7 +4583,10 @@ coff_slurp_line_table (bfd *abfd, asection *asect)
 		 ((symndx + obj_raw_syments (abfd))
 		  ->u.syment._n._n_n._n_zeroes));
 	  cache_ptr->u.sym = (asymbol *) sym;
-	  if (sym->lineno != NULL && ! warned)
+          if (sym == NULL)
+              continue;
+
+	  if (sym->lineno != NULL)
 	    (*_bfd_error_handler)
 	      (_("%B: warning: duplicate line number information for `%s'"),
 	       abfd, bfd_asymbol_name (&sym->symbol));
@@ -4616,7 +4629,7 @@ coff_slurp_line_table (bfd *abfd, asection *asect)
 
 	  /* Create the new sorted table.  */
 	  amt = ((bfd_size_type) asect->lineno_count + 1) * sizeof (alent);
-	  n_lineno_cache = (alent *) bfd_alloc (abfd, amt);
+	  n_lineno_cache = (alent *) bfd_zalloc (abfd, amt);
 	  if (n_lineno_cache != NULL)
 	    {
 	      alent *n_cache_ptr = n_lineno_cache;
@@ -4628,8 +4641,9 @@ coff_slurp_line_table (bfd *abfd, asection *asect)
 
 		  /* Copy the function entry and update it.  */
 		  *n_cache_ptr = *old_ptr;
-		  sym = (coff_symbol_type *)n_cache_ptr->u.sym;
-		  sym->lineno = n_cache_ptr;
+		  sym = (coff_symbol_type *) n_cache_ptr->u.sym;
+		  if (sym != NULL)
+		   sym->lineno = n_cache_ptr;
 		  n_cache_ptr++;
 		  old_ptr++;
 
@@ -4640,7 +4654,8 @@ coff_slurp_line_table (bfd *abfd, asection *asect)
 	      n_cache_ptr->line_number = 0;
 	      memcpy (lineno_cache, n_lineno_cache, amt);
 	    }
-	  bfd_release (abfd, func_table);
+	   /* PR binutils/17512: Do *not* free the func table
+	      and new lineno cache - they are now being used.  */
 	}
     }
 
diff --git a/bfd/coffgen.c b/bfd/coffgen.c
index 07a527d..b9dd0c4 100644
--- a/bfd/coffgen.c
+++ b/bfd/coffgen.c
@@ -86,9 +86,8 @@ make_a_section_from_file (bfd *abfd,
 	  strings = _bfd_coff_read_string_table (abfd);
 	  if (strings == NULL)
 	    return FALSE;
-	  /* FIXME: For extra safety, we should make sure that
-             strindex does not run us past the end, but right now we
-             don't know the length of the string table.  */
+	  if ((bfd_size_type)(strindex + 2) >= obj_coff_strings_len (abfd))
+	    return FALSE;
 	  strings += strindex;
 	  name = (char *) bfd_alloc (abfd,
                                      (bfd_size_type) strlen (strings) + 1 + 1);
@@ -466,6 +465,8 @@ _bfd_coff_internal_syment_name (bfd *abfd,
 	  if (strings == NULL)
 	    return NULL;
 	}
+      if (sym->_n._n_n._n_offset >= obj_coff_strings_len (abfd))
+       return NULL;
       return strings + sym->_n._n_n._n_offset;
     }
 }
@@ -1547,7 +1548,7 @@ coff_pointerize_aux (bfd *abfd,
    we didn't want to go to the trouble until someone needed it.  */
 
 static char *
-build_debug_section (bfd *abfd)
+build_debug_section (bfd *abfd, asection ** sect_return)
 {
   char *debug_section;
   file_ptr position;
@@ -1575,6 +1576,8 @@ build_debug_section (bfd *abfd)
       || bfd_bread (debug_section, sec_size, abfd) != sec_size
       || bfd_seek (abfd, position, SEEK_SET) != 0)
     return NULL;
+
+  * sect_return = sect;
   return debug_section;
 }
 
@@ -1618,6 +1621,12 @@ _bfd_coff_get_external_symbols (bfd *abfd)
   if (size == 0)
     return TRUE;
 
+  /* PR binutils/17512: Do not even try to load
+     a symbol table bigger than the entire file...  */
+  if (size >= (bfd_size_type) bfd_get_size (abfd))
+    return FALSE;
+
+
   syms = bfd_malloc (size);
   if (syms == NULL)
     return FALSE;
@@ -1637,7 +1646,9 @@ _bfd_coff_get_external_symbols (bfd *abfd)
 
 /* Read in the external strings.  The strings are not loaded until
    they are needed.  This is because we have no simple way of
-   detecting a missing string table in an archive.  */
+   detecting a missing string table in an archive.  If the strings
+   are loaded then the STRINGS and STRINGS_LEN fields in the
+   coff_tdata structure will be set.  */
 
 const char *
 _bfd_coff_read_string_table (bfd *abfd)
@@ -1698,7 +1709,7 @@ _bfd_coff_read_string_table (bfd *abfd)
       return NULL;
     }
 
-  obj_coff_strings (abfd) = strings;
+  obj_coff_strings_len (abfd) = strsize;
 
   return strings;
 }
@@ -1719,6 +1730,7 @@ _bfd_coff_free_symbols (bfd *abfd)
     {
       free (obj_coff_strings (abfd));
       obj_coff_strings (abfd) = NULL;
+      obj_coff_strings_len (abfd) = 0;
     }
   return TRUE;
 }
@@ -1739,13 +1751,22 @@ coff_get_normalized_symtab (bfd *abfd)
   char *raw_src;
   char *raw_end;
   const char *string_table = NULL;
-  char *debug_section = NULL;
+  asection * debug_sec = NULL;
+  char *debug_sec_data = NULL;
   bfd_size_type size;
 
   if (obj_raw_syments (abfd) != NULL)
     return obj_raw_syments (abfd);
 
-  size = obj_raw_syment_count (abfd) * sizeof (combined_entry_type);
+  size = obj_raw_syment_count (abfd);
+  if (size == 0)
+    return NULL;
+  /* PR binutils/17512: Do not even try to load
+     a symbol table bigger than the entire file...  */
+  if (size >= (bfd_size_type) bfd_get_size (abfd))
+    return NULL;
+
+  size *= sizeof (combined_entry_type);
   internal = (combined_entry_type *) bfd_zalloc (abfd, size);
   if (internal == NULL && size != 0)
     return NULL;
@@ -1779,6 +1800,10 @@ coff_get_normalized_symtab (bfd *abfd)
 	   i++)
 	{
 	  internal_ptr++;
+	  /* PR 17512: Prevent buffer overrun.  */
+	  if (internal_ptr >= internal_end)
+	    return NULL;
+
 	  raw_src += symesz;
 	  bfd_coff_swap_aux_in (abfd, (void *) raw_src,
 				symbol_ptr->u.syment.n_type,
@@ -1813,10 +1838,14 @@ coff_get_normalized_symtab (bfd *abfd)
 		    return NULL;
 		}
 
-	      internal_ptr->u.syment._n._n_n._n_offset =
-		((bfd_hostptr_t)
-		 (string_table
-		  + (internal_ptr + 1)->u.auxent.x_file.x_n.x_offset));
+	      if ((bfd_size_type)((internal_ptr + 1)->u.auxent.x_file.x_n.x_offset)
+	        >= obj_coff_strings_len (abfd))
+	        internal_ptr->u.syment._n._n_n._n_offset = (bfd_hostptr_t) _("<corrupt>");
+	      else
+	        internal_ptr->u.syment._n._n_n._n_offset =
+	          ((bfd_hostptr_t)
+	           (string_table
+	            + (internal_ptr + 1)->u.auxent.x_file.x_n.x_offset));
 	    }
 	  else
 	    {
@@ -1871,18 +1900,31 @@ coff_get_normalized_symtab (bfd *abfd)
 		  if (string_table == NULL)
 		    return NULL;
 		}
-	      internal_ptr->u.syment._n._n_n._n_offset =
-		((bfd_hostptr_t)
-		 (string_table
-		  + internal_ptr->u.syment._n._n_n._n_offset));
+	      if (internal_ptr->u.syment._n._n_n._n_offset >= obj_coff_strings_len (abfd))
+	        internal_ptr->u.syment._n._n_n._n_offset = (bfd_hostptr_t) _("<corrupt>");
+              else
+	        internal_ptr->u.syment._n._n_n._n_offset =
+	          ((bfd_hostptr_t)
+	           (string_table
+	            + internal_ptr->u.syment._n._n_n._n_offset));
 	    }
 	  else
 	    {
 	      /* Long name in debug section.  Very similar.  */
-	      if (debug_section == NULL)
-		debug_section = build_debug_section (abfd);
-	      internal_ptr->u.syment._n._n_n._n_offset = (bfd_hostptr_t)
-		(debug_section + internal_ptr->u.syment._n._n_n._n_offset);
+	      if (debug_sec_data == NULL)
+	        debug_sec_data = build_debug_section (abfd, & debug_sec);
+	      if (debug_sec_data != NULL)
+		{
+		  BFD_ASSERT (debug_sec != NULL);
+		  /* PR binutils/17512: Catch out of range offsets into the debug data.  */
+		  if (internal_ptr->u.syment._n._n_n._n_offset > debug_sec->size)
+		    internal_ptr->u.syment._n._n_n._n_offset = (bfd_hostptr_t) _("<corrupt>");
+		  else
+		    internal_ptr->u.syment._n._n_n._n_offset = (bfd_hostptr_t)
+		      (debug_sec_data + internal_ptr->u.syment._n._n_n._n_offset);
+		}
+	      else
+	       internal_ptr->u.syment._n._n_n._n_offset = (bfd_hostptr_t) "";
 	    }
 	}
       internal_ptr += internal_ptr->u.syment.n_numaux;
diff --git a/bfd/compress.c b/bfd/compress.c
index 46c2bcb..69a6e53 100644
--- a/bfd/compress.c
+++ b/bfd/compress.c
@@ -177,6 +177,14 @@ bfd_get_full_section_contents (bfd *abfd, sec_ptr sec, bfd_byte **ptr)
   switch (sec->compress_status)
     {
     case COMPRESS_SECTION_NONE:
+      /* PR binutils/17512: Avoid malloc or file reading errors due to
+        ridiculous section sizes.  But ignore linker created objects
+        and bfds with no contents (yet).  */
+      if (bfd_get_size (abfd) > 0
+ 	 && (sec->flags & SEC_LINKER_CREATED) == 0
+         && sz > (bfd_size_type) bfd_get_size (abfd))
+       return FALSE;
+
       if (p == NULL)
 	{
 	  p = (bfd_byte *) bfd_malloc (sz);
diff --git a/bfd/elf.c b/bfd/elf.c
index cf075bb..cb85c77 100644
--- a/bfd/elf.c
+++ b/bfd/elf.c
@@ -1576,6 +1576,7 @@ bfd_section_from_shdr (bfd *abfd, unsigned int shindex)
   const char *name;
   bfd_boolean ret = TRUE;
   static bfd_boolean * sections_being_created = NULL;
+  static bfd * sections_being_created_abfd = NULL;
   static unsigned int nesting = 0;
 
   if (shindex >= elf_numsections (abfd))
@@ -1588,13 +1589,20 @@ bfd_section_from_shdr (bfd *abfd, unsigned int shindex)
 	loop.  Detect this here, by refusing to load a section that we are
 	already in the process of loading.  We only trigger this test if
 	we have nested at least three sections deep as normal ELF binaries
-	can expect to recurse at least once.  */
+	can expect to recurse at least once.
+
+	FIXME: It would be better if this array was attached to the bfd,
+	rather than being held in a static pointer.  */
+
+	if (sections_being_created_abfd != abfd)
+	 sections_being_created = NULL;
 
 	if (sections_being_created == NULL)
 	  {
 		/* FIXME: It would be more efficient to attach this array to the bfd somehow.  */
 		sections_being_created = (bfd_boolean *)
 		  bfd_zalloc (abfd, elf_numsections (abfd) * sizeof (bfd_boolean));
+		sections_being_created_abfd = abfd;
 	  }
 	if (sections_being_created [shindex])
 	  {
@@ -2096,7 +2104,10 @@ bfd_section_from_shdr (bfd *abfd, unsigned int shindex)
   if (sections_being_created)
     sections_being_created [shindex] = FALSE;
   if (-- nesting == 0)
+  {
     sections_being_created = NULL;
+    sections_being_created_abfd = abfd;
+  }
   return ret;
 }
 
diff --git a/bfd/libcoff-in.h b/bfd/libcoff-in.h
index 49b5f10..eb7141c 100644
--- a/bfd/libcoff-in.h
+++ b/bfd/libcoff-in.h
@@ -35,6 +35,7 @@
 #define obj_coff_external_syms(bfd)   (coff_data (bfd)->external_syms)
 #define obj_coff_keep_syms(bfd)	      (coff_data (bfd)->keep_syms)
 #define obj_coff_strings(bfd)	      (coff_data (bfd)->strings)
+#define obj_coff_strings_len(bfd)     (coff_data (bfd)->strings_len)
 #define obj_coff_keep_strings(bfd)    (coff_data (bfd)->keep_strings)
 #define obj_coff_sym_hashes(bfd)      (coff_data (bfd)->sym_hashes)
 #define obj_coff_strings_written(bfd) (coff_data (bfd)->strings_written)
@@ -75,6 +76,8 @@ typedef struct coff_tdata
   /* The string table.  May be NULL.  Read by
      _bfd_coff_read_string_table.  */
   char *strings;
+  /* The length of the strings table.  For error checking.  */
+  bfd_size_type strings_len;
   /* If this is TRUE, the strings may not be freed.  */
   bfd_boolean keep_strings;
   /* If this is TRUE, the strings have been written out already.  */
diff --git a/bfd/libcoff.h b/bfd/libcoff.h
index 19b6d9c..a153e2a 100644
--- a/bfd/libcoff.h
+++ b/bfd/libcoff.h
@@ -39,6 +39,7 @@
 #define obj_coff_external_syms(bfd)   (coff_data (bfd)->external_syms)
 #define obj_coff_keep_syms(bfd)	      (coff_data (bfd)->keep_syms)
 #define obj_coff_strings(bfd)	      (coff_data (bfd)->strings)
+#define obj_coff_strings_len(bfd)     (coff_data (bfd)->strings_len)
 #define obj_coff_keep_strings(bfd)    (coff_data (bfd)->keep_strings)
 #define obj_coff_sym_hashes(bfd)      (coff_data (bfd)->sym_hashes)
 #define obj_coff_strings_written(bfd) (coff_data (bfd)->strings_written)
@@ -79,6 +80,8 @@ typedef struct coff_tdata
   /* The string table.  May be NULL.  Read by
      _bfd_coff_read_string_table.  */
   char *strings;
+  /* The length of the strings table.  For error checking.  */
+  bfd_size_type strings_len;
   /* If this is TRUE, the strings may not be freed.  */
   bfd_boolean keep_strings;
   /* If this is TRUE, the strings have been written out already.  */
diff --git a/bfd/peXXigen.c b/bfd/peXXigen.c
index fa1ff08..44e5212 100644
--- a/bfd/peXXigen.c
+++ b/bfd/peXXigen.c
@@ -1375,7 +1375,7 @@ pe_print_edata (bfd * abfd, void * vfile)
   bfd_size_type datasize = 0;
   bfd_size_type dataoff;
   bfd_size_type i;
-  bfd_signed_vma adj;
+  bfd_vma adj;
   struct EDT_type
   {
     long export_flags;          /* Reserved - should be zero.  */
@@ -1437,6 +1437,16 @@ pe_print_edata (bfd * abfd, void * vfile)
 	}
     }
 
+  /* PR 17512: Handle corrupt PE binaries.  */
+  if (datasize < 36)
+    {
+      fprintf (file,
+              _("\nThere is an export table in %s, but it is too small (%d)\n"),
+              section->name, (int) datasize);
+      return TRUE;
+    }
+
+
   fprintf (file, _("\nThere is an export table in %s at 0x%lx\n"),
 	   section->name, (unsigned long) addr);
 
@@ -1480,8 +1490,12 @@ pe_print_edata (bfd * abfd, void * vfile)
   fprintf (file,
 	   _("Name \t\t\t\t"));
   bfd_fprintf_vma (abfd, file, edt.name);
-  fprintf (file,
-	   " %s\n", data + edt.name - adj);
+  if ((edt.name >= adj) && (edt.name < adj + datasize))
+    fprintf (file, " %.*s\n",
+           (int) (datasize - (edt.name - adj)),
+           data + edt.name - adj);
+  else
+    fprintf (file, "(outside .edata section)\n");
 
   fprintf (file,
 	   _("Ordinal Base \t\t\t%ld\n"), edt.base);
@@ -1528,7 +1542,11 @@ pe_print_edata (bfd * abfd, void * vfile)
 	  edt.base);
 
   /* PR 17512: Handle corrupt PE binaries.  */
-  if (edt.eat_addr + (edt.num_functions * 4) - adj >= datasize)
+  if (edt.eat_addr + (edt.num_functions * 4) - adj >= datasize
+      /* PR 17512: file: 092b1829 */
+      || (edt.num_functions * 4) < edt.num_functions
+      /* PR 17512 file: 140-165018-0.004.  */
+      || data + edt.eat_addr - adj < data)
 	fprintf (file, _("\tInvalid Export Address Table rva (0x%lx) or entry count (0x%lx)\n"),
 	     (long) edt.eat_addr,
 	     (long) edt.num_functions);
@@ -1544,11 +1562,12 @@ pe_print_edata (bfd * abfd, void * vfile)
 	  	 /* This rva is to a name (forwarding function) in our section.  */
 	   	 /* Should locate a function descriptor.  */
 	  	  fprintf (file,
-		   "\t[%4ld] +base[%4ld] %04lx %s -- %s\n",
+		   "\t[%4ld] +base[%4ld] %04lx %s -- %.*s\n",
 		   (long) i,
 		   (long) (i + edt.base),
 		   (unsigned long) eat_member,
 		   _("Forwarder RVA"),
+                   (int)(datasize - (eat_member - adj)),
 		   data + eat_member - adj);
 	         }
       		else
@@ -1568,30 +1587,40 @@ pe_print_edata (bfd * abfd, void * vfile)
   fprintf (file,
 	   _("\n[Ordinal/Name Pointer] Table\n"));
   /* PR 17512: Handle corrupt PE binaries.  */
-  if (edt.npt_addr + (edt.num_names * 4) - adj >= datasize)
+  if (edt.npt_addr + (edt.num_names * 4) - adj >= datasize
+      /* PR 17512: file: bb68816e.  */
+      || edt.num_names * 4 < edt.num_names
+      || (data + edt.npt_addr - adj) < data)
   	fprintf (file, _("\tInvalid Name Pointer Table rva (0x%lx) or entry count (0x%lx)\n"),
 	        (long) edt.npt_addr,
 		(long) edt.num_names);
-  else if (edt.ot_addr + (edt.num_names * 2) - adj >= datasize)
+  /* PR 17512: file: 140-147171-0.004.  */
+  else if (edt.ot_addr + (edt.num_names * 2) - adj >= datasize
+          || data + edt.ot_addr - adj < data)
 	fprintf (file, _("\tInvalid Ordinal Table rva (0x%lx) or entry count (0x%lx)\n"),
 		(long) edt.ot_addr,
 		(long) edt.num_names);
   else for (i = 0; i < edt.num_names; ++i)
-    	{
-     	 bfd_vma name_ptr = bfd_get_32 (abfd,
-				    data +
-				    edt.npt_addr
-				    + (i*4) - adj);
-
-      	char *name = (char *) data + name_ptr - adj;
-
-      	bfd_vma ord = bfd_get_16 (abfd,
-				    data +
-				    edt.ot_addr
-				    + (i*2) - adj);
-      	fprintf (file,
-	      "\t[%4ld] %s\n", (long) ord, name);
-       }	
+    {
+      bfd_vma  name_ptr;
+      bfd_vma  ord;
+
+      ord = bfd_get_16 (abfd, data + edt.ot_addr + (i * 2) - adj);
+      name_ptr = bfd_get_32 (abfd, data + edt.npt_addr + (i * 4) - adj);
+
+      if ((name_ptr - adj) >= datasize)
+       {
+         fprintf (file, _("\t[%4ld] <corrupt offset: %lx>\n"),
+                  (long) ord, (long) name_ptr);
+       }
+      else
+       {
+         char * name = (char *) data + name_ptr - adj;
+
+         fprintf (file, "\t[%4ld] %.*s\n", (long) ord,
+                  (int)((char *)(data + datasize) - name), name);        
+       }
+    }	
 
   free (data);
 
diff --git a/bfd/xcofflink.c b/bfd/xcofflink.c
index d0bfd29..0ca36fa 100644
--- a/bfd/xcofflink.c
+++ b/bfd/xcofflink.c
@@ -4484,7 +4484,10 @@ xcoff_link_input_bfd (struct xcoff_final_link_info *flinfo,
 			  if (strings == NULL)
 			    return FALSE;
 			}
-		      filename = strings + aux.x_file.x_n.x_offset;
+		      if ((bfd_size_type) aux.x_file.x_n.x_offset >= obj_coff_strings_len (input_bfd))
+			filename = _("<corrupt>");
+		      else
+			filename = strings + aux.x_file.x_n.x_offset;
 		      indx = _bfd_stringtab_add (flinfo->strtab, filename,
 						 hash, copy);
 		      if (indx == (bfd_size_type) -1)
diff --git a/binutils/objdump.c b/binutils/objdump.c
index cfd08e9..5cece33 100644
--- a/binutils/objdump.c
+++ b/binutils/objdump.c
@@ -563,7 +563,10 @@ slurp_symtab (bfd *abfd)
 
   storage = bfd_get_symtab_upper_bound (abfd);
   if (storage < 0)
-    bfd_fatal (bfd_get_filename (abfd));
+    {
+      non_fatal (_("failed to read symbol table from: %s"), bfd_get_filename (abfd));
+      bfd_fatal (_("error message was"));
+    }
   if (storage)
     sy = (asymbol **) xmalloc (storage);
 
@@ -3106,7 +3109,11 @@ dump_relocs_in_section (bfd *abfd,
   relcount = bfd_canonicalize_reloc (abfd, section, relpp, syms);
 
   if (relcount < 0)
-    bfd_fatal (bfd_get_filename (abfd));
+    {
+      printf ("\n");
+      non_fatal (_("failed to read relocs in: %s"), bfd_get_filename (abfd));
+      bfd_fatal (_("error message was"));
+    }
   else if (relcount == 0)
     printf (" (none)\n\n");
   else
-- 
1.7.1

