From 6b9dea9de8d5b26e1db1e779bfe1c92443cdc427 Mon Sep 17 00:00:00 2001
From: Emilia Kasper <emilia@openssl.org>
Date: Wed, 24 Feb 2016 12:59:59 +0100
Subject: [PATCH 4/7] CVE-2016-0798: avoid memory leak in SRP

commit 59a908f1e8380412a81392c468b83bf6071beb2a upstream
git://git.openssl.org/openssl.git

The SRP user database lookup method SRP_VBASE_get_by_user had confusing
memory management semantics; the returned pointer was sometimes newly
allocated, and sometimes owned by the callee. The calling code has no
way of distinguishing these two cases.

Specifically, SRP servers that configure a secret seed to hide valid
login information are vulnerable to a memory leak: an attacker
connecting with an invalid username can cause a memory leak of around
300 bytes per connection.

Servers that do not configure SRP, or configure SRP but do not configure
a seed are not vulnerable.

In Apache, the seed directive is known as SSLSRPUnknownUserSeed.

To mitigate the memory leak, the seed handling in SRP_VBASE_get_by_user
is now disabled even if the user has configured a seed.

Applications are advised to migrate to SRP_VBASE_get1_by_user. However,
note that OpenSSL makes no strong guarantees about the
indistinguishability of valid and invalid logins. In particular,
computations are currently not carried out in constant time.

Upstream Status: Backport
CVE: CVE-2016-0798

Reviewed-by: Rich Salz <rsalz@openssl.org>
Signed-off-by: Zhang Xiao <xiao.zhang@windriver.com>
---
 apps/s_server.c      | 24 ++++++++++++------
 crypto/srp/srp.h     | 10 ++++++++
 crypto/srp/srp_vfy.c | 70 +++++++++++++++++++++++++++++++++++++++++++---------
 openssl.ld           |  4 +++
 util/libeay.num      |  2 ++
 5 files changed, 90 insertions(+), 20 deletions(-)

diff --git a/apps/s_server.c b/apps/s_server.c
index e362773..332ef85 100644
--- a/apps/s_server.c
+++ b/apps/s_server.c
@@ -414,6 +414,7 @@ typedef struct srpsrvparm_st
 static int MS_CALLBACK ssl_srp_server_param_cb(SSL *s, int *ad, void *arg)
 	{
 	srpsrvparm *p = (srpsrvparm *)arg;
+	int ret = SSL3_AL_FATAL;
 	if (p->login == NULL && p->user == NULL )
 		{
 		p->login = SSL_get_srp_username(s);
@@ -424,19 +425,22 @@ static int MS_CALLBACK ssl_srp_server_param_cb(SSL *s, int *ad, void *arg)
 	if (p->user == NULL)
 		{
 		BIO_printf(bio_err, "User %s doesn't exist\n", p->login);
-		return SSL3_AL_FATAL;
+		goto err;
 		}
 	if (SSL_set_srp_server_param(s, p->user->N, p->user->g, p->user->s, p->user->v,
 				     p->user->info) < 0)
 		{
 		*ad = SSL_AD_INTERNAL_ERROR;
-		return SSL3_AL_FATAL;
+		goto err;
 		}
 	BIO_printf(bio_err, "SRP parameters set: username = \"%s\" info=\"%s\" \n", p->login,p->user->info);
-	/* need to check whether there are memory leaks */
+	ret = SSL_ERROR_NONE;
+
+err:
+	SRP_user_pwd_free(p->user);
 	p->user = NULL;
 	p->login = NULL;
-	return SSL_ERROR_NONE;
+	return ret;
 	}
 
 #endif
@@ -2291,7 +2295,8 @@ static int sv_body(char *hostname, int s, unsigned char *context)
 				while (SSL_get_error(con,k) == SSL_ERROR_WANT_X509_LOOKUP)
 					{
 					BIO_printf(bio_s_out,"LOOKUP renego during write\n");
-					srp_callback_parm.user = SRP_VBASE_get_by_user(srp_callback_parm.vb, srp_callback_parm.login); 
+					SRP_user_pwd_free(srp_callback_parm.user);
+					srp_callback_parm.user = SRP_VBASE_get1_by_user(srp_callback_parm.vb, srp_callback_parm.login); 
 					if (srp_callback_parm.user) 
 						BIO_printf(bio_s_out,"LOOKUP done %s\n",srp_callback_parm.user->info);
 					else 
@@ -2350,7 +2355,8 @@ again:
 				while (SSL_get_error(con,i) == SSL_ERROR_WANT_X509_LOOKUP)
 					{
 					BIO_printf(bio_s_out,"LOOKUP renego during read\n");
-					srp_callback_parm.user = SRP_VBASE_get_by_user(srp_callback_parm.vb, srp_callback_parm.login); 
+					SRP_user_pwd_free(srp_callback_parm.user);
+					srp_callback_parm.user = SRP_VBASE_get1_by_user(srp_callback_parm.vb, srp_callback_parm.login); 
 					if (srp_callback_parm.user) 
 						BIO_printf(bio_s_out,"LOOKUP done %s\n",srp_callback_parm.user->info);
 					else 
@@ -2439,7 +2445,8 @@ static int init_ssl_connection(SSL *con)
 	while (i <= 0 &&  SSL_get_error(con,i) == SSL_ERROR_WANT_X509_LOOKUP) 
 		{
 			BIO_printf(bio_s_out,"LOOKUP during accept %s\n",srp_callback_parm.login);
-			srp_callback_parm.user = SRP_VBASE_get_by_user(srp_callback_parm.vb, srp_callback_parm.login); 
+			SRP_user_pwd_free(srp_callback_parm.user);
+			srp_callback_parm.user = SRP_VBASE_get1_by_user(srp_callback_parm.vb, srp_callback_parm.login); 
 			if (srp_callback_parm.user) 
 				BIO_printf(bio_s_out,"LOOKUP done %s\n",srp_callback_parm.user->info);
 			else 
@@ -2681,7 +2688,8 @@ static int www_body(char *hostname, int s, unsigned char *context)
 			while (i <= 0 &&  SSL_get_error(con,i) == SSL_ERROR_WANT_X509_LOOKUP) 
 		{
 			BIO_printf(bio_s_out,"LOOKUP during accept %s\n",srp_callback_parm.login);
-			srp_callback_parm.user = SRP_VBASE_get_by_user(srp_callback_parm.vb, srp_callback_parm.login); 
+			SRP_user_pwd_free(srp_callback_parm.user);
+			srp_callback_parm.user = SRP_VBASE_get1_by_user(srp_callback_parm.vb, srp_callback_parm.login); 
 			if (srp_callback_parm.user) 
 				BIO_printf(bio_s_out,"LOOKUP done %s\n",srp_callback_parm.user->info);
 			else 
diff --git a/crypto/srp/srp.h b/crypto/srp/srp.h
index 7ec7825..b2522cb 100644
--- a/crypto/srp/srp.h
+++ b/crypto/srp/srp.h
@@ -83,16 +83,21 @@ DECLARE_STACK_OF(SRP_gN_cache)
 
 typedef struct SRP_user_pwd_st
 	{
+	/* Owned by us. */
 	char *id;
 	BIGNUM *s;
 	BIGNUM *v;
+	/* Not owned by us. */
 	const BIGNUM *g;
 	const BIGNUM *N;
+	/* Owned by us. */
 	char *info;
 	} SRP_user_pwd;
 
 DECLARE_STACK_OF(SRP_user_pwd)
 
+void SRP_user_pwd_free(SRP_user_pwd *user_pwd);
+
 typedef struct SRP_VBASE_st
 	{
 	STACK_OF(SRP_user_pwd) *users_pwd;
@@ -117,7 +122,12 @@ DECLARE_STACK_OF(SRP_gN)
 SRP_VBASE *SRP_VBASE_new(char *seed_key);
 int SRP_VBASE_free(SRP_VBASE *vb);
 int SRP_VBASE_init(SRP_VBASE *vb, char * verifier_file);
+
+/* This method ignores the configured seed and fails for an unknown user. */
 SRP_user_pwd *SRP_VBASE_get_by_user(SRP_VBASE *vb, char *username);
+/* NOTE: unlike in SRP_VBASE_get_by_user, caller owns the returned pointer.*/
+SRP_user_pwd *SRP_VBASE_get1_by_user(SRP_VBASE *vb, char *username);
+
 char *SRP_create_verifier(const char *user, const char *pass, char **salt,
 			  char **verifier, const char *N, const char *g);
 int SRP_create_verifier_BN(const char *user, const char *pass, BIGNUM **salt, BIGNUM **verifier, BIGNUM *N, BIGNUM *g);
diff --git a/crypto/srp/srp_vfy.c b/crypto/srp/srp_vfy.c
index fdca19f..1613f65 100644
--- a/crypto/srp/srp_vfy.c
+++ b/crypto/srp/srp_vfy.c
@@ -182,7 +182,7 @@ static char *t_tob64(char *dst, const unsigned char *src, int size)
 	return olddst;
 	}
 
-static void SRP_user_pwd_free(SRP_user_pwd *user_pwd)
+void SRP_user_pwd_free(SRP_user_pwd *user_pwd)
 	{
 	if (user_pwd == NULL) 
 		return;
@@ -222,6 +222,31 @@ static int SRP_user_pwd_set_ids(SRP_user_pwd *vinfo, const char *id,
 	return (info == NULL || NULL != (vinfo->info = BUF_strdup(info))) ;
 	}
 
+static int SRP_user_pwd_set_sv_BN(SRP_user_pwd *vinfo, BIGNUM *s, BIGNUM *v)
+	{
+	vinfo->v = v;
+	vinfo->s = s;
+	return (vinfo->s != NULL && vinfo->v != NULL) ;
+	}
+
+static SRP_user_pwd *srp_user_pwd_dup(SRP_user_pwd *src)
+	{
+	SRP_user_pwd *ret;
+
+	if (src == NULL)
+		return NULL;
+	if ((ret = SRP_user_pwd_new()) == NULL)
+		return NULL;
+
+	SRP_user_pwd_set_gN(ret, src->g, src->N);
+	if (!SRP_user_pwd_set_ids(ret, src->id, src->info)
+	    || !SRP_user_pwd_set_sv_BN(ret, BN_dup(src->s), BN_dup(src->v))) {
+		SRP_user_pwd_free(ret);
+		return NULL;
+	}
+	return ret;
+	}
+
 static int SRP_user_pwd_set_sv(SRP_user_pwd *vinfo, const char *s,
 			       const char *v)
 	{
@@ -237,13 +262,6 @@ static int SRP_user_pwd_set_sv(SRP_user_pwd *vinfo, const char *s,
 	return ((vinfo->s = BN_bin2bn(tmp, len, NULL)) != NULL) ;
 	}
 
-static int SRP_user_pwd_set_sv_BN(SRP_user_pwd *vinfo, BIGNUM *s, BIGNUM *v)
-	{
-	vinfo->v = v;
-	vinfo->s = s;
-	return (vinfo->s != NULL && vinfo->v != NULL) ;
-	}
-
 SRP_VBASE *SRP_VBASE_new(char *seed_key)
 	{
 	SRP_VBASE *vb = (SRP_VBASE *) OPENSSL_malloc(sizeof(SRP_VBASE));
@@ -475,22 +493,50 @@ int SRP_VBASE_init(SRP_VBASE *vb, char *verifier_file)
 	}
 
 
-SRP_user_pwd *SRP_VBASE_get_by_user(SRP_VBASE *vb, char *username)
+static SRP_user_pwd *find_user(SRP_VBASE *vb, char *username)
 	{
 	int i;
 	SRP_user_pwd *user;
-	unsigned char digv[SHA_DIGEST_LENGTH];
-	unsigned char digs[SHA_DIGEST_LENGTH];
-	EVP_MD_CTX ctxt;
 
 	if (vb == NULL)
 		return NULL;
+
 	for(i = 0; i < sk_SRP_user_pwd_num(vb->users_pwd); i++)
 		{
 		user = sk_SRP_user_pwd_value(vb->users_pwd, i);
 		if (strcmp(user->id,username)==0)
 			return user;
 		}
+	return NULL;
+	}
+
+/*
+ * This method ignores the configured seed and fails for an unknown user.
+ * Ownership of the returned pointer is not released to the caller.
+ * In other words, caller must not free the result.
+ */
+SRP_user_pwd *SRP_VBASE_get_by_user(SRP_VBASE *vb, char *username)
+	{
+	return find_user(vb, username);
+	}
+
+/*
+ * Ownership of the returned pointer is released to the caller.
+ * In other words, caller must free the result once done.
+ */
+SRP_user_pwd *SRP_VBASE_get1_by_user(SRP_VBASE *vb, char *username)
+	{
+	SRP_user_pwd *user;
+	unsigned char digv[SHA_DIGEST_LENGTH];
+	unsigned char digs[SHA_DIGEST_LENGTH];
+	EVP_MD_CTX ctxt;
+
+	if (vb == NULL)
+		return NULL;
+
+	if ((user = find_user(vb, username)) != NULL)
+		return srp_user_pwd_dup(user);
+
 	if ((vb->seed_key == NULL) ||
 		(vb->default_g == NULL) ||
 		(vb->default_N == NULL))
diff --git a/openssl.ld b/openssl.ld
index 09b3df2..71cd6c4 100644
--- a/openssl.ld
+++ b/openssl.ld
@@ -4506,6 +4506,10 @@ OPENSSL_1.0.1 {
 		SSL_SESSION_get_compress_id;
 
 		SRP_VBASE_get_by_user;
+		SRP_VBASE_get1_by_user;
+		SRP_user_pwd_free;
+		SRP_VBASE_get1_by_user;
+		SRP_user_pwd_free;
 		SRP_Calc_server_key;
 		SRP_create_verifier;
 		SRP_create_verifier_BN;
diff --git a/util/libeay.num b/util/libeay.num
index aa86b2b..ef26d5d 100755
--- a/util/libeay.num
+++ b/util/libeay.num
@@ -1806,6 +1806,8 @@ d2i_ASN1_SET_OF_PKCS12_SAFEBAG          2341	NOEXIST::FUNCTION:
 ASN1_UTCTIME_get                        2350	NOEXIST::FUNCTION:
 X509_REQ_digest                         2362	EXIST::FUNCTION:EVP
 X509_CRL_digest                         2391	EXIST::FUNCTION:EVP
+SRP_VBASE_get1_by_user                  2393	EXIST::FUNCTION:SRP
+SRP_user_pwd_free                       2394	EXIST::FUNCTION:SRP
 d2i_ASN1_SET_OF_PKCS7                   2397	NOEXIST::FUNCTION:
 EVP_CIPHER_CTX_set_key_length           2399	EXIST::FUNCTION:
 EVP_CIPHER_CTX_ctrl                     2400	EXIST::FUNCTION:
-- 
1.9.1

