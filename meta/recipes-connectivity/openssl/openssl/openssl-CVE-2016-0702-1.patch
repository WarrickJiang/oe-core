From fccf05112457df427ad6a2ab9bc8d1ea53a21c10 Mon Sep 17 00:00:00 2001
From: Andy Polyakov <appro@openssl.org>
Date: Tue, 26 Jan 2016 11:34:41 +0100
Subject: [PATCH 6/7] bn/bn_exp.c: constant-time
 MOD_EXP_CTIME_COPY_FROM_PREBUF.

commit d7a854c055ff22fb7da80c3b0e7cb08d248591d0 upstream
git://git.openssl.org/openssl.git

Performance penalty varies from platform to platform, and even
key length. For rsa2048 sign it was observed to reach almost 10%.

CVE-2016-0702

Upstream Status: Backport
CVE: CVE-2016-0702

Reviewed-by: Richard Levitte <levitte@openssl.org>
Signed-off-by: Zhang Xiao <xiao.zhang@windriver.com>
---
 crypto/bn/bn_exp.c | 65 +++++++++++++++++++++++++++++++++++++++++++-----------
 1 file changed, 52 insertions(+), 13 deletions(-)

diff --git a/crypto/bn/bn_exp.c b/crypto/bn/bn_exp.c
index 7de46ff..469a7f8 100644
--- a/crypto/bn/bn_exp.c
+++ b/crypto/bn/bn_exp.c
@@ -111,6 +111,7 @@
 
 
 #include "cryptlib.h"
+#include "constant_time_locl.h"
 #include "bn_lcl.h"
 
 #include <stdlib.h>
@@ -534,32 +535,70 @@ err:
  * as cache lines are concerned.  The following functions are used to transfer a BIGNUM
  * from/to that table. */
 
-static int MOD_EXP_CTIME_COPY_TO_PREBUF(const BIGNUM *b, int top, unsigned char *buf, int idx, int width)
+static int MOD_EXP_CTIME_COPY_TO_PREBUF(const BIGNUM *b, int top, unsigned char *buf, int idx, int window)
 	{
-	size_t i, j;
+	int i, j;
+	int width = 1 << window;
+	BN_ULONG *table = (BN_ULONG *)buf;
 
 	if (top > b->top)
 		top = b->top; /* this works because 'buf' is explicitly zeroed */
-	for (i = 0, j=idx; i < top * sizeof b->d[0]; i++, j+=width)
+	for (i = 0, j=idx; i < top; i++, j+=width)
 		{
-		buf[j] = ((unsigned char*)b->d)[i];
+		table[j] = b->d[i];
 		}
 
 	return 1;
 	}
 
-static int MOD_EXP_CTIME_COPY_FROM_PREBUF(BIGNUM *b, int top, unsigned char *buf, int idx, int width)
+static int MOD_EXP_CTIME_COPY_FROM_PREBUF(BIGNUM *b, int top, unsigned char *buf, int idx, int window)
 	{
-	size_t i, j;
+	int i, j;
+	int width = 1 << window;
+	volatile BN_ULONG *table = (volatile BN_ULONG *)buf;
 
 	if (bn_wexpand(b, top) == NULL)
 		return 0;
 
-	for (i=0, j=idx; i < top * sizeof b->d[0]; i++, j+=width)
-		{
-		((unsigned char*)b->d)[i] = buf[j];
+	if (window <= 3) {
+ 		for (i = 0; i < top; i++, table += width) {
+ 			BN_ULONG acc = 0;
+
+		for (j = 0; j < width; j++) {
+			acc |= table[j] &
+			       ((BN_ULONG)0 - (constant_time_eq_int(j,idx)&1));
+		}
+
+		b->d[i] = acc;
+		}
+	} else {
+		int xstride = 1 << (window - 2);
+		BN_ULONG y0, y1, y2, y3;
+
+		i = idx >> (window - 2);        /* equivalent of idx / xstride */
+		idx &= xstride - 1;             /* equivalent of idx % xstride */
+
+		y0 = (BN_ULONG)0 - (constant_time_eq_int(i,0)&1);
+		y1 = (BN_ULONG)0 - (constant_time_eq_int(i,1)&1);
+		y2 = (BN_ULONG)0 - (constant_time_eq_int(i,2)&1);
+		y3 = (BN_ULONG)0 - (constant_time_eq_int(i,3)&1);
+
+		for (i = 0; i < top; i++, table += width) {
+			BN_ULONG acc = 0;
+
+			for (j = 0; j < xstride; j++) {
+				acc |= ( (table[j + 0 * xstride] & y0) |
+					 (table[j + 1 * xstride] & y1) |
+					 (table[j + 2 * xstride] & y2) |
+					 (table[j + 3 * xstride] & y3) )
+					& ((BN_ULONG)0 - (constant_time_eq_int(j,idx)&1));
 		}
 
+		b->d[i] = acc;
+		}
+	}
+
+
 	b->top = top;
 	bn_correct_top(b);
 	return 1;
@@ -767,8 +806,8 @@ int BN_mod_exp_mont_consttime(BIGNUM *rr, const BIGNUM *a, const BIGNUM *p,
     else
 #endif
 	{
-	if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, 0, numPowers)) goto err;
-	if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&am,  top, powerbuf, 1, numPowers)) goto err;
+	if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, 0, window)) goto err;
+	if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&am,  top, powerbuf, 1, window)) goto err;
 
 	/* If the window size is greater than 1, then calculate
 	 * val[i=2..2^winsize-1]. Powers are computed as a*a^(i-1)
@@ -778,20 +778,20 @@ int BN_mod_exp_mont_consttime(BIGNUM *rr, const BIGNUM *a, const BIGNUM *p,
 	if (window > 1)
 		{
 		if (!BN_mod_mul_montgomery(&tmp,&am,&am,mont,ctx))	goto err;
-		if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, 2, numPowers)) goto err;
+		if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, 2, window)) goto err;
 		for (i=3; i<numPowers; i++)
 			{
 			/* Calculate a^i = a^(i-1) * a */
 			if (!BN_mod_mul_montgomery(&tmp,&am,&tmp,mont,ctx))
 				goto err;
-			if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, i, numPowers)) goto err;
+			if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, i, window)) goto err;
 			}
 		}
 
 	bits--;
 	for (wvalue=0, i=bits%window; i>=0; i--,bits--)
 		wvalue = (wvalue<<1)+BN_is_bit_set(p,bits);
-	if (!MOD_EXP_CTIME_COPY_FROM_PREBUF(&tmp,top,powerbuf,wvalue,numPowers)) goto err;
+	if (!MOD_EXP_CTIME_COPY_FROM_PREBUF(&tmp,top,powerbuf,wvalue,window)) goto err;
  
 	/* Scan the exponent one window at a time starting from the most
 	 * significant bits.
@@ -808,7 +808,7 @@ int BN_mod_exp_mont_consttime(BIGNUM *rr, const BIGNUM *a, const BIGNUM *p,
   			}
  		
 		/* Fetch the appropriate pre-computed value from the pre-buf */
-		if (!MOD_EXP_CTIME_COPY_FROM_PREBUF(&am, top, powerbuf, wvalue, numPowers)) goto err;
+		if (!MOD_EXP_CTIME_COPY_FROM_PREBUF(&am, top, powerbuf, wvalue, window)) goto err;
 
  		/* Multiply the result into the intermediate result */
  		if (!BN_mod_mul_montgomery(&tmp,&tmp,&am,mont,ctx)) goto err;
-- 
1.9.1

